<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tanjun.parsing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tanjun.parsing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

__all__: typing.Sequence[str] = [
    &#34;Argument&#34;,
    &#34;Option&#34;,
    &#34;ShlexParser&#34;,
    &#34;parser_descriptor&#34;,
    &#34;verify_parameters&#34;,
    &#34;with_argument&#34;,
    &#34;with_greedy_argument&#34;,
    &#34;with_multi_argument&#34;,
    &#34;with_option&#34;,
    &#34;with_multi_option&#34;,
    &#34;with_parser&#34;,
    &#34;with_typed_parameters&#34;,
]

import asyncio
import copy
import itertools
import shlex
import typing

from hikari import undefined

from tanjun import conversion
from tanjun import errors
from tanjun import traits

CommandT = typing.TypeVar(&#34;CommandT&#34;, traits.CommandDescriptor, traits.ExecutableCommand, contravariant=True)
CommandDescriptorT = typing.TypeVar(&#34;CommandDescriptorT&#34;, bound=traits.CommandDescriptor)
GREEDY = &#34;greedy&#34;
&#34;&#34;&#34;Parameter flags key used for marking a parameter as &#34;greedy&#34;.

This means that the parameter will take in the rest of the positional
arguments as one value.

!!! note
    This cannot be used in conjunction with &#34;multi&#34; and only applies
    to arguments (not options).
&#34;&#34;&#34;
MULTI = &#34;multi&#34;
&#34;&#34;&#34;Parameter flags key used for marking a parameter as &#34;multi&#34;.

This will result in the parameter always receiving an array of results.

!!! note
    This cannot be used in conjunction with &#34;greedy&#34; and can apply to both
    options and arguments.
&#34;&#34;&#34;


class ShlexTokenizer:
    __slots__: typing.Sequence[str] = (&#34;__arg_buffer&#34;, &#34;__last_name&#34;, &#34;__options_buffer&#34;, &#34;__shlex&#34;)

    def __init__(self, content: str, /) -&gt; None:
        self.__arg_buffer: typing.MutableSequence[str] = []
        self.__last_name: typing.Optional[str] = None
        self.__options_buffer: typing.MutableSequence[typing.Tuple[str, typing.Optional[str]]] = []
        self.__shlex = shlex.shlex(content, posix=True)
        self.__shlex.whitespace = &#34; &#34;
        self.__shlex.whitespace_split = True

    def collect_raw_options(self) -&gt; typing.Mapping[str, typing.Sequence[typing.Optional[str]]]:
        results: typing.MutableMapping[str, typing.MutableSequence[typing.Optional[str]]] = {}

        while (option_ := self.next_raw_option()) is not None:
            name, value = option_

            if name not in results:
                results[name] = []

            results[name].append(value)

        return results

    def iter_raw_arguments(self) -&gt; typing.Iterator[str]:
        while (argument_ := self.next_raw_argument()) is not None:
            yield argument_

    def next_raw_argument(self) -&gt; typing.Optional[str]:
        if self.__arg_buffer:
            return self.__arg_buffer.pop(0)

        while isinstance(value := self.__seek_shlex(), tuple):
            self.__options_buffer.append(value)

        return value

    def next_raw_option(self) -&gt; typing.Optional[typing.Tuple[str, typing.Optional[str]]]:
        if self.__options_buffer:
            return self.__options_buffer.pop(0)

        while isinstance(value := self.__seek_shlex(), str):
            self.__arg_buffer.append(value)

        return value

    def __seek_shlex(self) -&gt; typing.Union[str, typing.Tuple[str, typing.Optional[str]], None]:
        option_name = self.__last_name

        try:
            value = next(self.__shlex)

        except StopIteration:
            if option_name is not None:
                self.__last_name = None
                return (option_name, None)

            return None

        except ValueError as exc:
            raise errors.ParserError(str(exc), None) from exc

        is_option = value.startswith(&#34;-&#34;)
        if is_option and option_name is not None:
            self.__last_name = value
            return (option_name, None)

        if is_option:
            self.__last_name = value
            return self.__seek_shlex()

        if option_name:
            self.__last_name = None
            return (option_name, value)

        return value


async def _covert_option_or_empty(
    ctx: traits.Context, option_: traits.Option, value: typing.Optional[typing.Any], /
) -&gt; typing.Any:
    if value is not None:
        return await option_.convert(ctx, value)

    if option_.empty_value is not traits.UNDEFINED_DEFAULT:
        return option_.empty_value

    raise errors.NotEnoughArgumentsError(f&#34;Option &#39;{option_.key} cannot be empty.&#34;, option_)


class SemanticShlex(ShlexTokenizer):
    __slots__: typing.Sequence[str] = (&#34;__ctx&#34;,)

    def __init__(self, ctx: traits.Context, /) -&gt; None:
        super().__init__(ctx.content)
        self.__ctx = ctx

    async def get_arguments(self, arguments: typing.Sequence[traits.Argument], /) -&gt; typing.MutableSequence[typing.Any]:
        results: typing.MutableSequence[typing.Any] = []
        for argument_ in arguments:
            results.append(await self.__process_argument(argument_))

            if argument_.flags.get(GREEDY) or argument_.flags.get(MULTI):
                break  # Multi and Greedy parameters should always be the last parameter.

        return results

    async def get_options(self, options: typing.Sequence[traits.Option], /) -&gt; typing.MutableMapping[str, typing.Any]:
        raw_options = self.collect_raw_options()
        results = asyncio.gather(*map(lambda option_: self.__process_option(option_, raw_options), options))
        return dict(zip((option_.key for option_ in options), await results))

    async def __process_argument(self, argument_: traits.Parameter) -&gt; typing.Any:
        if argument_.flags.get(GREEDY) and (value := &#34; &#34;.join(self.iter_raw_arguments())):
            return await argument_.convert(self.__ctx, value)

        if argument_.flags.get(MULTI) and (values := list(self.iter_raw_arguments())):
            return await asyncio.gather(*(argument_.convert(self.__ctx, value) for value in values))

        # If the previous two statements failed on getting raw arguments then this will as well.
        if (optional_value := self.next_raw_argument()) is not None:
            return await argument_.convert(self.__ctx, optional_value)

        if argument_.default is not traits.UNDEFINED_DEFAULT:
            return argument_.default

        # If this is reached then no value was found.
        raise errors.NotEnoughArgumentsError(f&#34;Missing value for required argument &#39;{argument_.key}&#39;&#34;, argument_)

    async def __process_option(
        self, option_: traits.Option, raw_options: typing.Mapping[str, typing.Sequence[typing.Optional[str]]]
    ) -&gt; typing.Any:
        values_iter = itertools.chain.from_iterable(raw_options[name] for name in option_.names if name in raw_options)
        is_multi = option_.flags.get(MULTI, False)
        if is_multi and (values := list(values_iter)):
            return asyncio.gather(*(_covert_option_or_empty(self.__ctx, option_, value) for value in values))

        if not is_multi and (value := next(values_iter, undefined.UNDEFINED)) is not undefined.UNDEFINED:
            if next(values_iter, undefined.UNDEFINED) is not undefined.UNDEFINED:
                raise errors.TooManyArgumentsError(f&#34;Option `{option_.key}` can only take a single value&#34;, option_)

            return await _covert_option_or_empty(self.__ctx, option_, value)

        if option_.default is not traits.UNDEFINED_DEFAULT:
            return option_.default

        # If this is reached then no value was found.
        raise errors.NotEnoughArgumentsError(f&#34;Missing required option `{option_.key}`&#34;, option_)


def with_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an argument to a command or command descriptor through a decorator call.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_argument(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT, /) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add a parameter to a command client without a parser.&#34;)

        argument = Argument(key, converters=converters, default=default, flags=flags)
        command.parser.add_parameter(argument)
        return command

    return decorator


def with_greedy_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A greedy argument will consume the remaining positional arguments and pass
        them through to the converters as one joined string while also requiring
        that at least one more positional argument is remaining unless a
        default is set.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_greedy_argument(&#34;command&#34;, converters=(StringView,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: StringView):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[GREEDY] = True
    return with_argument(key, converters=converters, default=default, flags=flags)


def with_multi_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A multi argument will consume the remaining positional arguments and pass
        them to the converters through multiple calls while also requiring that
        at least one more positional argument is remaining unless a default is
        set and passing through the results to the command&#39;s function as a
        sequence.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_argument(&#34;command&#34;, converters=(int,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_argument(key, converters=converters, default=default, flags=flags)


def with_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an option to a command or command descriptor through a decorator call.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_option(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add an option to a command client without a parser.&#34;)

        option = Option(
            key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags,
        )
        command.parser.add_parameter(option)
        return command

    return decorator


def with_multi_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an multi-option to a command or command descriptor through a decorator call.

    !!! note
        A multi option will consume all the values provided for an option and
        pass them through to the converters as an array of strings while also
        requiring that at least one value is provided for the option unless
        a default is set.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_option(&#34;command&#34;, converters=(int,), default=())
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_option(key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags)


class _Parameter(traits.Parameter):
    __slots__: typing.Sequence[str] = (&#34;_converters&#34;, &#34;default&#34;, &#34;_flags&#34;, &#34;key&#34;)

    def __init__(
        self,
        key: str,
        /,
        *,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
    ) -&gt; None:
        self._converters: typing.Optional[typing.MutableSequence[traits.ConverterT]] = None
        self.default = default
        self._flags = dict(flags) if flags else {}
        self.key = key

        if key.startswith(&#34;-&#34;):
            raise ValueError(&#34;parameter key cannot start with `-`&#34;)

        if converters is not None:
            for converter in converters:
                self.add_converter(converter)

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__} &lt;{self.key}&gt;&#34;

    @property
    def converters(self) -&gt; typing.Optional[typing.Sequence[traits.ConverterT]]:
        return tuple(self._converters) if self._converters is not None else None

    @property
    def flags(self) -&gt; typing.MutableMapping[str, typing.Any]:
        return self._flags

    def add_converter(self, converter: traits.ConverterT, /) -&gt; None:
        if self._converters is None:
            self._converters = []

        # Some builtin types like `bool` and `bytes` are overridden here for the sake of convenience.
        self._converters.append(conversion.override_builtin_type(converter))

    def remove_converter(self, converter: traits.ConverterT, /) -&gt; None:
        if self._converters is None:
            raise ValueError(&#34;No converters set&#34;)

        self._converters.remove(converter)

        if not self._converters:
            self._converters = None

    def bind_client(self, client: traits.Client, /) -&gt; None:
        if not self._converters:
            return

        for converter in self._converters:
            if isinstance(converter, (traits.Converter, traits.StatelessConverter)):
                converter.bind_client(client)

    def bind_component(self, component: traits.Component, /) -&gt; None:
        if not self._converters:
            return

        for converter in self._converters:
            if isinstance(converter, (traits.Converter, traits.StatelessConverter)):
                converter.bind_component(component)

    async def convert(self, ctx: traits.Context, value: str) -&gt; typing.Any:
        if self._converters is None:
            return value

        sources: typing.MutableSequence[ValueError] = []
        for converter in self._converters:
            try:
                if hasattr(converter, &#34;convert&#34;):
                    converter = typing.cast(&#34;traits.Converter[typing.Any]&#34;, converter)
                    result = await converter.convert(ctx, value)
                    return result

                converter = typing.cast(&#34;typing.Callable[[str], typing.Any]&#34;, converter)
                return converter(value)

            except ValueError as exc:
                sources.append(exc)

        raise errors.ConversionError(self, sources)


class Argument(_Parameter, traits.Argument):
    __slots__: typing.Sequence[str] = ()

    def __init__(
        self,
        key: str,
        /,
        *,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
    ) -&gt; None:
        if flags and MULTI in flags and GREEDY in flags:
            raise ValueError(&#34;Argument cannot be both greed and multi.&#34;)

        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Argument:
        return Argument(
            self.key,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
        )


class Option(_Parameter, traits.Option):
    __slots__: typing.Sequence[str] = (&#34;empty_value&#34;, &#34;names&#34;)

    def __init__(
        self,
        key: str,
        name: str,
        *names: str,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
        empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    ) -&gt; None:
        names = [name, *names]

        if not all(n.startswith(&#34;-&#34;) for n in names):
            raise ValueError(&#34;All option names must start with `-`&#34;)

        if flags and GREEDY in flags:
            raise ValueError(&#34;Option cannot be greedy&#34;)

        self.empty_value = empty_value
        self.names = names
        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Option:
        # TODO: this will error if there&#39;s no set names.
        return Option(
            self.key,
            *self.names,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
            empty_value=self.empty_value,
        )

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__} &lt;{self.key}, {self.names}&gt;&#34;


class ShlexParser(traits.Parser):
    &#34;&#34;&#34;A shlex based `tanjun.traits.Parser` implementation.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_arguments&#34;, &#34;_options&#34;)

    def __init__(self, *, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; None:
        self._arguments: typing.MutableSequence[traits.Argument] = []
        self._options: typing.MutableSequence[traits.Option] = []

        if parameters is not None:
            self.set_parameters(parameters)

    @property
    def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        return (*self._arguments, *self._options)

    def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.append(parameter)

        else:
            self._arguments.append(parameter)
            found_final_argument = False

            for argument_ in self._arguments:
                if found_final_argument:
                    del self._arguments[-1]
                    raise ValueError(&#34;Multi or greedy argument must be the last argument&#34;)

                found_final_argument = MULTI in argument_.flags or GREEDY in argument_.flags

    def remove_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.remove(parameter)

        else:
            self._arguments.remove(parameter)

    def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        self._arguments = []
        self._options = []

        for parameter_ in parameters:
            self.add_parameter(parameter_)

    def bind_client(self, client: traits.Client, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_client(client)

    def bind_component(self, component: traits.Component, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_component(component)

    async def parse(
        self, ctx: traits.Context, /
    ) -&gt; typing.Tuple[typing.Sequence[typing.Any], typing.Mapping[str, typing.Any]]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        parser = SemanticShlex(ctx)
        arguments = await parser.get_arguments(self._arguments)
        options = await parser.get_options(self._options)
        return arguments, options


class ParserDescriptor(traits.ParserDescriptor):
    &#34;&#34;&#34;Descriptor used for pre-defining the parameters of a `ShlexParser`.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_parameters&#34;,)

    def __init__(self, *, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; None:
        self._parameters = list(parameters) if parameters else []

    def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
        # &lt;&lt;inherited docstring from tanjun.traits.ParserDescriptor&gt;&gt;.
        return tuple(self._parameters)

    def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ParserDescriptor&gt;&gt;.
        self._parameters.append(parameter)

    def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ParserDescriptor&gt;&gt;.
        self._parameters = list(parameters)

    def build_parser(self, component: traits.Component, /) -&gt; ShlexParser:
        # &lt;&lt;inherited docstring from tanjun.traits.ParserDescriptor&gt;&gt;.
        parser = ShlexParser(parameters=map(copy.copy, self._parameters))
        parser.bind_component(component)
        return parser


def parser_descriptor(*, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; ParserDescriptor:
    &#34;&#34;&#34;Build a shlex parser descriptor.&#34;&#34;&#34;
    return ParserDescriptor(parameters=parameters)


# Unlike the other decorators in this module, this can only be applied to a command descriptor.
def with_parser(command: CommandDescriptorT, /) -&gt; CommandDescriptorT:
    &#34;&#34;&#34;Add a shlex parser descriptor to a command descriptor.&#34;&#34;&#34;
    command.parser = parser_descriptor()
    return command


def with_typed_parameters(command: CommandT, /, *, ignore_self: bool) -&gt; CommandT:
    # TODO: implement this to enable generating parameters from a function&#39;s signature.
    if command.parser is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no parser&#34;)

    if command.function is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no function&#34;)

    raise NotImplementedError


def verify_parameters(command: CommandT, /) -&gt; CommandT:
    # TODO: implement this to verify the parameters of a command against the function signature
    return command</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tanjun.parsing.parser_descriptor"><code class="name flex">
<span>def <span class="ident">parser_descriptor</span></span>(<span>*, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) ‑> tanjun.parsing.ParserDescriptor</span>
</code></dt>
<dd>
<div class="desc"><p>Build a shlex parser descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser_descriptor(*, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; ParserDescriptor:
    &#34;&#34;&#34;Build a shlex parser descriptor.&#34;&#34;&#34;
    return ParserDescriptor(parameters=parameters)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.verify_parameters"><code class="name flex">
<span>def <span class="ident">verify_parameters</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_parameters(command: CommandT, /) -&gt; CommandT:
    # TODO: implement this to verify the parameters of a command against the function signature
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_argument"><code class="name flex">
<span>def <span class="ident">with_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an argument to a command or command descriptor through a decorator call.</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[traits.ConverterT]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_argument(&quot;command&quot;, converters=(int,), default=42)
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: int):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an argument to a command or command descriptor through a decorator call.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_argument(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT, /) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add a parameter to a command client without a parser.&#34;)

        argument = Argument(key, converters=converters, default=default, flags=flags)
        command.parser.add_parameter(argument)
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_greedy_argument"><code class="name flex">
<span>def <span class="ident">with_greedy_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add a greedy argument to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A greedy argument will consume the remaining positional arguments and pass
them through to the converters as one joined string while also requiring
that at least one more positional argument is remaining unless a
default is set.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[traits.ConverterT]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_greedy_argument(&quot;command&quot;, converters=(StringView,))
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: StringView):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_greedy_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A greedy argument will consume the remaining positional arguments and pass
        them through to the converters as one joined string while also requiring
        that at least one more positional argument is remaining unless a
        default is set.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_greedy_argument(&#34;command&#34;, converters=(StringView,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: StringView):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[GREEDY] = True
    return with_argument(key, converters=converters, default=default, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_multi_argument"><code class="name flex">
<span>def <span class="ident">with_multi_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add a greedy argument to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A multi argument will consume the remaining positional arguments and pass
them to the converters through multiple calls while also requiring that
at least one more positional argument is remaining unless a default is
set and passing through the results to the command's function as a
sequence.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[traits.ConverterT]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_multi_argument(&quot;command&quot;, converters=(int,))
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_multi_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A multi argument will consume the remaining positional arguments and pass
        them to the converters through multiple calls while also requiring that
        at least one more positional argument is remaining unless a default is
        set and passing through the results to the command&#39;s function as a
        sequence.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_argument(&#34;command&#34;, converters=(int,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_argument(key, converters=converters, default=default, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_multi_option"><code class="name flex">
<span>def <span class="ident">with_multi_option</span></span>(<span>key: str, name: str, /, *names: str, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, default: typing.Any, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an multi-option to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A multi option will consume all the values provided for an option and
pass them through to the converters as an array of strings while also
requiring that at least one value is provided for the option unless
a default is set.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this option which will be used to pass the
result of this argument to the command's function during execution as
a keyword argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, unlike arguments this is required
for options.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Other names of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[traits.ConverterT]]</code></dt>
<dd>An iterable of the converters this option should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>empty_value</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The value to use if this option is provided without a value. If left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this option will error if it's
provided without a value.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this option with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
option.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_multi_option(&quot;command&quot;, converters=(int,), default=())
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_multi_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an multi-option to a command or command descriptor through a decorator call.

    !!! note
        A multi option will consume all the values provided for an option and
        pass them through to the converters as an array of strings while also
        requiring that at least one value is provided for the option unless
        a default is set.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_option(&#34;command&#34;, converters=(int,), default=())
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_option(key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_option"><code class="name flex">
<span>def <span class="ident">with_option</span></span>(<span>key: str, name: str, /, *names: str, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, default: typing.Any, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an option to a command or command descriptor through a decorator call.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this option which will be used to pass the
result of this argument to the command's function during execution as
a keyword argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, unlike arguments this is required
for options.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Other names of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[traits.ConverterT]]</code></dt>
<dd>An iterable of the converters this option should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>empty_value</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The value to use if this option is provided without a value. If left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this option will error if it's
provided without a value.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this option with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
option.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_option(&quot;command&quot;, converters=(int,), default=42)
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: int):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an option to a command or command descriptor through a decorator call.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_option(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add an option to a command client without a parser.&#34;)

        option = Option(
            key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags,
        )
        command.parser.add_parameter(option)
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_parser"><code class="name flex">
<span>def <span class="ident">with_parser</span></span>(<span>command: CommandDescriptorT, /) ‑> ~CommandDescriptorT</span>
</code></dt>
<dd>
<div class="desc"><p>Add a shlex parser descriptor to a command descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_parser(command: CommandDescriptorT, /) -&gt; CommandDescriptorT:
    &#34;&#34;&#34;Add a shlex parser descriptor to a command descriptor.&#34;&#34;&#34;
    command.parser = parser_descriptor()
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.with_typed_parameters"><code class="name flex">
<span>def <span class="ident">with_typed_parameters</span></span>(<span>command: CommandT, /, *, ignore_self: bool) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_typed_parameters(command: CommandT, /, *, ignore_self: bool) -&gt; CommandT:
    # TODO: implement this to enable generating parameters from a function&#39;s signature.
    if command.parser is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no parser&#34;)

    if command.function is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no function&#34;)

    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tanjun.parsing.Argument"><code class="flex name class">
<span>class <span class="ident">Argument</span></span>
<span>(</span><span>key: str, /, *, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.Mapping[str, typing.Any]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Argument(_Parameter, traits.Argument):
    __slots__: typing.Sequence[str] = ()

    def __init__(
        self,
        key: str,
        /,
        *,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
    ) -&gt; None:
        if flags and MULTI in flags and GREEDY in flags:
            raise ValueError(&#34;Argument cannot be both greed and multi.&#34;)

        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Argument:
        return Argument(
            self.key,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.parsing._Parameter</li>
<li><a title="tanjun.traits.Argument" href="traits.html#tanjun.traits.Argument">Argument</a></li>
<li><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="tanjun.parsing.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>key: str, name: str, *names: str, converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.Mapping[str, typing.Any]] = None, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Option(_Parameter, traits.Option):
    __slots__: typing.Sequence[str] = (&#34;empty_value&#34;, &#34;names&#34;)

    def __init__(
        self,
        key: str,
        name: str,
        *names: str,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
        empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    ) -&gt; None:
        names = [name, *names]

        if not all(n.startswith(&#34;-&#34;) for n in names):
            raise ValueError(&#34;All option names must start with `-`&#34;)

        if flags and GREEDY in flags:
            raise ValueError(&#34;Option cannot be greedy&#34;)

        self.empty_value = empty_value
        self.names = names
        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Option:
        # TODO: this will error if there&#39;s no set names.
        return Option(
            self.key,
            *self.names,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
            empty_value=self.empty_value,
        )

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__} &lt;{self.key}, {self.names}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.parsing._Parameter</li>
<li><a title="tanjun.traits.Option" href="traits.html#tanjun.traits.Option">Option</a></li>
<li><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.parsing.Option.empty_value"><code class="name">var <span class="ident">empty_value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.parsing.Option.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="tanjun.parsing.ShlexParser"><code class="flex name class">
<span>class <span class="ident">ShlexParser</span></span>
<span>(</span><span>*, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A shlex based <code><a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a></code> implementation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShlexParser(traits.Parser):
    &#34;&#34;&#34;A shlex based `tanjun.traits.Parser` implementation.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_arguments&#34;, &#34;_options&#34;)

    def __init__(self, *, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; None:
        self._arguments: typing.MutableSequence[traits.Argument] = []
        self._options: typing.MutableSequence[traits.Option] = []

        if parameters is not None:
            self.set_parameters(parameters)

    @property
    def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        return (*self._arguments, *self._options)

    def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.append(parameter)

        else:
            self._arguments.append(parameter)
            found_final_argument = False

            for argument_ in self._arguments:
                if found_final_argument:
                    del self._arguments[-1]
                    raise ValueError(&#34;Multi or greedy argument must be the last argument&#34;)

                found_final_argument = MULTI in argument_.flags or GREEDY in argument_.flags

    def remove_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.remove(parameter)

        else:
            self._arguments.remove(parameter)

    def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        self._arguments = []
        self._options = []

        for parameter_ in parameters:
            self.add_parameter(parameter_)

    def bind_client(self, client: traits.Client, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_client(client)

    def bind_component(self, component: traits.Component, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_component(component)

    async def parse(
        self, ctx: traits.Context, /
    ) -&gt; typing.Tuple[typing.Sequence[typing.Any], typing.Mapping[str, typing.Any]]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        parser = SemanticShlex(ctx)
        arguments = await parser.get_arguments(self._arguments)
        options = await parser.get_options(self._options)
        return arguments, options</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.parsing.ShlexParser.parameters"><code class="name">var <span class="ident">parameters</span> : Sequence[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    return (*self._arguments, *self._options)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.parsing.ShlexParser.add_parameter"><code class="name flex">
<span>def <span class="ident">add_parameter</span></span>(<span>self, parameter: traits.Parameter, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    if isinstance(parameter, traits.Option):
        self._options.append(parameter)

    else:
        self._arguments.append(parameter)
        found_final_argument = False

        for argument_ in self._arguments:
            if found_final_argument:
                del self._arguments[-1]
                raise ValueError(&#34;Multi or greedy argument must be the last argument&#34;)

            found_final_argument = MULTI in argument_.flags or GREEDY in argument_.flags</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.ShlexParser.bind_client"><code class="name flex">
<span>def <span class="ident">bind_client</span></span>(<span>self, client: traits.Client, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_client(self, client: traits.Client, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    for parameter in itertools.chain(self._options, self._arguments):
        parameter.bind_client(client)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.ShlexParser.bind_component"><code class="name flex">
<span>def <span class="ident">bind_component</span></span>(<span>self, component: traits.Component, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_component(self, component: traits.Component, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    for parameter in itertools.chain(self._options, self._arguments):
        parameter.bind_component(component)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.ShlexParser.parse"><code class="name flex">
<span>async def <span class="ident">parse</span></span>(<span>self, ctx: traits.Context, /) ‑> Tuple[Sequence[Any], Mapping[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def parse(
    self, ctx: traits.Context, /
) -&gt; typing.Tuple[typing.Sequence[typing.Any], typing.Mapping[str, typing.Any]]:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    parser = SemanticShlex(ctx)
    arguments = await parser.get_arguments(self._arguments)
    options = await parser.get_options(self._options)
    return arguments, options</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.ShlexParser.remove_parameter"><code class="name flex">
<span>def <span class="ident">remove_parameter</span></span>(<span>self, parameter: traits.Parameter, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_parameter(self, parameter: traits.Parameter, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    if isinstance(parameter, traits.Option):
        self._options.remove(parameter)

    else:
        self._arguments.remove(parameter)</code></pre>
</details>
</dd>
<dt id="tanjun.parsing.ShlexParser.set_parameters"><code class="name flex">
<span>def <span class="ident">set_parameters</span></span>(<span>self, parameters: typing.Iterable[traits.Parameter], /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    self._arguments = []
    self._options = []

    for parameter_ in parameters:
        self.add_parameter(parameter_)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tanjun" href="index.html">tanjun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tanjun.parsing.parser_descriptor" href="#tanjun.parsing.parser_descriptor">parser_descriptor</a></code></li>
<li><code><a title="tanjun.parsing.verify_parameters" href="#tanjun.parsing.verify_parameters">verify_parameters</a></code></li>
<li><code><a title="tanjun.parsing.with_argument" href="#tanjun.parsing.with_argument">with_argument</a></code></li>
<li><code><a title="tanjun.parsing.with_greedy_argument" href="#tanjun.parsing.with_greedy_argument">with_greedy_argument</a></code></li>
<li><code><a title="tanjun.parsing.with_multi_argument" href="#tanjun.parsing.with_multi_argument">with_multi_argument</a></code></li>
<li><code><a title="tanjun.parsing.with_multi_option" href="#tanjun.parsing.with_multi_option">with_multi_option</a></code></li>
<li><code><a title="tanjun.parsing.with_option" href="#tanjun.parsing.with_option">with_option</a></code></li>
<li><code><a title="tanjun.parsing.with_parser" href="#tanjun.parsing.with_parser">with_parser</a></code></li>
<li><code><a title="tanjun.parsing.with_typed_parameters" href="#tanjun.parsing.with_typed_parameters">with_typed_parameters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tanjun.parsing.Argument" href="#tanjun.parsing.Argument">Argument</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.parsing.Option" href="#tanjun.parsing.Option">Option</a></code></h4>
<ul class="">
<li><code><a title="tanjun.parsing.Option.empty_value" href="#tanjun.parsing.Option.empty_value">empty_value</a></code></li>
<li><code><a title="tanjun.parsing.Option.names" href="#tanjun.parsing.Option.names">names</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.parsing.ShlexParser" href="#tanjun.parsing.ShlexParser">ShlexParser</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.parsing.ShlexParser.add_parameter" href="#tanjun.parsing.ShlexParser.add_parameter">add_parameter</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.bind_client" href="#tanjun.parsing.ShlexParser.bind_client">bind_client</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.bind_component" href="#tanjun.parsing.ShlexParser.bind_component">bind_component</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.parameters" href="#tanjun.parsing.ShlexParser.parameters">parameters</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.parse" href="#tanjun.parsing.ShlexParser.parse">parse</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.remove_parameter" href="#tanjun.parsing.ShlexParser.remove_parameter">remove_parameter</a></code></li>
<li><code><a title="tanjun.parsing.ShlexParser.set_parameters" href="#tanjun.parsing.ShlexParser.set_parameters">set_parameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>