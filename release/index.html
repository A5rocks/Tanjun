<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tanjun API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>tanjun</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

__all__: typing.Sequence[str] = [
    # checks.py
    &#34;checks&#34;,
    &#34;with_dm_check&#34;,
    &#34;with_guild_check&#34;,
    &#34;with_nsfw_check&#34;,
    &#34;with_sfw_check&#34;,
    &#34;with_owner_check&#34;,
    &#34;with_author_permission_check&#34;,
    &#34;with_bot_permission_check&#34;,
    # clients.py
    &#34;clients&#34;,
    &#34;as_loader&#34;,
    &#34;Client&#34;,
    # command.py
    &#34;commands&#34;,
    &#34;Command&#34;,
    &#34;CommandGroup&#34;,
    # components.py
    &#34;components&#34;,
    &#34;as_command&#34;,
    &#34;as_event&#34;,
    &#34;as_group&#34;,
    &#34;Component&#34;,
    # context.py
    &#34;context&#34;,
    &#34;Context&#34;,
    # conversion.py
    &#34;conversion&#34;,
    &#34;ChannelConverter&#34;,
    &#34;ColorConverter&#34;,
    &#34;EmojiConverter&#34;,
    &#34;GuildConverter&#34;,
    &#34;InviteConverter&#34;,
    &#34;MemberConverter&#34;,
    &#34;PresenceConverter&#34;,
    &#34;RoleConverter&#34;,
    &#34;SnowflakeConverter&#34;,
    &#34;UserConverter&#34;,
    &#34;VoiceStateConverter&#34;,
    # errors.py
    &#34;errors&#34;,
    &#34;CommandError&#34;,
    &#34;ConversionError&#34;,
    &#34;FailedCheck&#34;,
    &#34;NotEnoughArgumentsError&#34;,
    &#34;TooManyArgumentsError&#34;,
    &#34;ParserError&#34;,
    &#34;TanjunError&#34;,
    &#34;TanjunWarning&#34;,
    &#34;StateWarning&#34;,
    # hooks.py
    &#34;hooks&#34;,
    &#34;Hooks&#34;,
    # parsing.py
    &#34;parsing&#34;,
    &#34;Argument&#34;,
    &#34;Option&#34;,
    &#34;ShlexParser&#34;,
    &#34;parser_descriptor&#34;,
    &#34;verify_parameters&#34;,
    &#34;with_argument&#34;,
    &#34;with_greedy_argument&#34;,
    &#34;with_multi_argument&#34;,
    &#34;with_option&#34;,
    &#34;with_multi_option&#34;,
    &#34;with_parser&#34;,
    &#34;with_typed_parameters&#34;,
    # traits.py
    &#34;traits&#34;,
]

import typing

from tanjun import traits
from tanjun.checks import *
from tanjun.clients import *
from tanjun.commands import *
from tanjun.components import *
from tanjun.context import *
from tanjun.conversion import *
from tanjun.errors import *
from tanjun.hooks import *
from tanjun.parsing import *</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="tanjun.about" href="about.html">tanjun.about</a></code></dt>
<dd>
<div class="desc"><p>Package metadata.</p></div>
</dd>
<dt><code class="name"><a title="tanjun.checks" href="checks.html">tanjun.checks</a></code></dt>
<dd>
<div class="desc"><p>A collection of common standard checks designed for Tanjun commands.</p></div>
</dd>
<dt><code class="name"><a title="tanjun.clients" href="clients.html">tanjun.clients</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.commands" href="commands.html">tanjun.commands</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.components" href="components.html">tanjun.components</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.context" href="context.html">tanjun.context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.conversion" href="conversion.html">tanjun.conversion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.errors" href="errors.html">tanjun.errors</a></code></dt>
<dd>
<div class="desc"><p>The errors and warnings raised within and by Tanjun.</p></div>
</dd>
<dt><code class="name"><a title="tanjun.hooks" href="hooks.html">tanjun.hooks</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.parsing" href="parsing.html">tanjun.parsing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tanjun.traits" href="traits.html">tanjun.traits</a></code></dt>
<dd>
<div class="desc"><p>Interfaces of the objects used within Tanjun.</p></div>
</dd>
<dt><code class="name"><a title="tanjun.utilities" href="utilities.html">tanjun.utilities</a></code></dt>
<dd>
<div class="desc"><p>Collection of utility functions used within Tanjun.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tanjun.as_command"><code class="name flex">
<span>def <span class="ident">as_command</span></span>(<span>name: str, /, *names: str, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, parser: typing.Optional[<a title="tanjun.traits.ParserDescriptor" href="traits.html#tanjun.traits.ParserDescriptor">ParserDescriptor</a>] = None) ‑> Callable[[Callable[..., Coroutine[Any, Any, Any]]], tanjun.components.CommandDescriptor]</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a command descriptor on a component's class.</p>
<p>The returned descriptor will be loaded into the component it's attached to
during initialisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for this command.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Additional names for this command passed as variable positional arguments.</dd>
<dt><strong><code>checks</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]]</code></dt>
<dd>An iterable of async or non-async check functions which should take
one positional argument of type <code><a title="tanjun.Context" href="#tanjun.Context">Context</a></code> and return <code>builtins.bool</code>
or raise <code><a title="tanjun.errors.FailedCheck" href="errors.html#tanjun.errors.FailedCheck">FailedCheck</a></code> where <code><a title="tanjun.FailedCheck" href="#tanjun.FailedCheck">FailedCheck</a></code> or <code>False</code> will
prevent the command from being chosen for execution.</dd>
<dt><strong><code>hooks</code></strong> :&ensp;<code>typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]</code></dt>
<dd>The execution hooks this command should be calling.</dd>
<dt><strong><code>parser</code></strong> :&ensp;<code>typing.Optional[<a title="tanjun.traits.ParserDescriptor" href="traits.html#tanjun.traits.ParserDescriptor">ParserDescriptor</a>]</code></dt>
<dd>A descriptor of the parser this command should use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[traits.CommandFunctionT], CommandDescriptor]</code></dt>
<dd>A decorator function for a command function.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Methods and attributes on the returned descriptor can be modified directly
or using decorators in-order to fine tune the behaviour of this command
(e.g. set a parser for the command) as shown below.</p>
<pre><code class="language-python">import tanjun

class MyComponent(tanjun.components.Component):
    @tanjun.parsing.with_greedy_argument(&quot;content&quot;, converters=None)
    @tanjun.parsing.with_parser
    @tanjun.checks.with_owner_check
    @tanjun.components.as_command(&quot;echo&quot;)
    async def echo_command(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
        await ctx.message.reply(content)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_command(
    name: str,
    /,
    *names: str,
    checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
    hooks: typing.Optional[traits.Hooks] = None,
    parser: typing.Optional[traits.ParserDescriptor] = None,
) -&gt; typing.Callable[[traits.CommandFunctionT], CommandDescriptor]:
    &#34;&#34;&#34;Declare a command descriptor on a component&#39;s class.

    The returned descriptor will be loaded into the component it&#39;s attached to
    during initialisation.

    Parameters
    ----------
    name : str
        The name for this command.

    Other Parameters
    ----------------
    *names : str
        Additional names for this command passed as variable positional arguments.
    checks : typing.Optional[typing.Iterable[traits.CheckT]]
        An iterable of async or non-async check functions which should take
        one positional argument of type `Context` and return `builtins.bool`
        or raise `tanjun.errors.FailedCheck` where `FailedCheck` or `False` will
        prevent the command from being chosen for execution.
    hooks : typing.Optional[traits.Hooks]
        The execution hooks this command should be calling.
    parser : typing.Optional[traits.ParserDescriptor]
        A descriptor of the parser this command should use.

    Returns
    -------
    typing.Callable[[traits.CommandFunctionT], CommandDescriptor]
        A decorator function for a command function.

    Examples
    --------
    Methods and attributes on the returned descriptor can be modified directly
    or using decorators in-order to fine tune the behaviour of this command
    (e.g. set a parser for the command) as shown below.

    ```python
    import tanjun

    class MyComponent(tanjun.components.Component):
        @tanjun.parsing.with_greedy_argument(&#34;content&#34;, converters=None)
        @tanjun.parsing.with_parser
        @tanjun.checks.with_owner_check
        @tanjun.components.as_command(&#34;echo&#34;)
        async def echo_command(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
            await ctx.message.reply(content)
    ```
    &#34;&#34;&#34;

    def decorator(function: traits.CommandFunctionT, /) -&gt; CommandDescriptor:
        return CommandDescriptor(checks, function, hooks, (name, *names), parser)

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.as_event"><code class="name flex">
<span>def <span class="ident">as_event</span></span>(<span>cls: typing.Type[event_dispatcher.EventT_inv], /) ‑> EventDecoratorT[event_dispatcher.EventT_inv]</span>
</code></dt>
<dd>
<div class="desc"><p>Declare an event listener</p>
<p>The returned descriptor will be loaded into the component it's attached to
during initialisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>typing.Type[hikari.api.event_dispatcher.EventT_inv]</code></dt>
<dd>The Hikari event class this listener should be called for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventDecoratorT[event_dispatcher.EventT_inv]</code></dt>
<dd>The callable event decorator which takes the event's asynchronous
listener function (with signature {self, event, /}) as it's only
positional argument and returns a listener descriptor.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">from hikari import events
import tanjun

class MyComponent(tanjun.components.Component):
    @tanjun.components.event(events.GuildVisibilityEvent):
    async def on_guild_visibility_event(self, event: events.GuildVisibilityEvent) -&gt; None:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_event(cls: typing.Type[event_dispatcher.EventT_inv], /) -&gt; EventDecoratorT[event_dispatcher.EventT_inv]:
    &#34;&#34;&#34;Declare an event listener

    The returned descriptor will be loaded into the component it&#39;s attached to
    during initialisation.

    Parameters
    ----------
    cls : typing.Type[hikari.api.event_dispatcher.EventT_inv]
        The Hikari event class this listener should be called for.

    Returns
    -------
    EventDecoratorT[event_dispatcher.EventT_inv]
        The callable event decorator which takes the event&#39;s asynchronous
        listener function (with signature {self, event, /}) as it&#39;s only
        positional argument and returns a listener descriptor.

    Examples
    --------
    ```python
    from hikari import events
    import tanjun

    class MyComponent(tanjun.components.Component):
        @tanjun.components.event(events.GuildVisibilityEvent):
        async def on_guild_visibility_event(self, event: events.GuildVisibilityEvent) -&gt; None:
            ...
    ```
    &#34;&#34;&#34;

    def decorator(
        function: event_dispatcher.CallbackT[event_dispatcher.EventT_inv], /
    ) -&gt; event_dispatcher.CallbackT[event_dispatcher.EventT_inv]:
        return ListenerDescriptor(cls, function)

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.as_group"><code class="name flex">
<span>def <span class="ident">as_group</span></span>(<span>name: str, /, *names: str, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, parser: typing.Optional[<a title="tanjun.traits.ParserDescriptor" href="traits.html#tanjun.traits.ParserDescriptor">ParserDescriptor</a>] = None) ‑> Callable[[Callable[..., Coroutine[Any, Any, Any]]], tanjun.components.CommandGroupDescriptor]</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a command group descriptor on a component's class.</p>
<p>The returned descriptor will be loaded into the component it's attached to
during initialisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for this command group.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Additional names for this command group passed as variable positional arguments.</dd>
<dt><strong><code>checks</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]]</code></dt>
<dd>An iterable of async or non-async check functions which should take
one positional argument of type <code><a title="tanjun.Context" href="#tanjun.Context">Context</a></code> and return <code>builtins.bool</code>
or raise <code><a title="tanjun.errors.FailedCheck" href="errors.html#tanjun.errors.FailedCheck">FailedCheck</a></code> where <code><a title="tanjun.FailedCheck" href="#tanjun.FailedCheck">FailedCheck</a></code> or <code>False</code> will
prevent the command from being chosen for execution.</dd>
<dt><strong><code>hooks</code></strong> :&ensp;<code>typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]</code></dt>
<dd>The execution hooks this command should be calling.</dd>
<dt><strong><code>parser</code></strong> :&ensp;<code>typing.Optional[<a title="tanjun.traits.ParserDescriptor" href="traits.html#tanjun.traits.ParserDescriptor">ParserDescriptor</a>]</code></dt>
<dd>A descriptor of the parser this command should use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[traits.CommandFunctionT], CommandGroupDescriptor]</code></dt>
<dd>A decorator function for a command function.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Methods and attributes on the returned descriptor can be modified directly
or using decorators in-order to fine tune the behaviour of this command
(e.g. set a parser for the command) as shown below.</p>
<pre><code class="language-python">import tanjun

class MyComponent(tanjun.components.Component):
    @tanjun.parsing.with_greedy_argument(&quot;content&quot;, converters=None)
    @tanjun.parsing.with_parser
    @tanjun.checks.with_owner_check
    @tanjun.components.as_group(&quot;help&quot;)
    async def help(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
        await ctx.message.reply(f&quot;`{content}` is not a valid help command&quot;)
</code></pre>
<p>The <code>CommandGroupDescriptor.with_command</code> can be called on the returned
descriptor in-order to add sub-commands to this group as shown below.</p>
<pre><code class="language-python">import tanjun

class MyComponent(tanjun.components.Component):
    @tanjun.parsing.with_greedy_argument(&quot;content&quot;, converters=None)
    @tanjun.parsing.with_parser
    @tanjun.components.group(&quot;help&quot;)
    async def help(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
        await ctx.message.reply(f&quot;`{content}` is not a valid help command&quot;)

    @help.with_command(&quot;me&quot;)
    async def help_me(self, ctx: tanjun.traits.Context) -&gt; None:
        await ctx.message.reply(f&quot;There is no reset for you, {ctx.message.author}&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_group(
    name: str,
    /,
    *names: str,
    checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
    hooks: typing.Optional[traits.Hooks] = None,
    parser: typing.Optional[traits.ParserDescriptor] = None,
) -&gt; typing.Callable[[traits.CommandFunctionT], CommandGroupDescriptor]:
    &#34;&#34;&#34;Declare a command group descriptor on a component&#39;s class.

    The returned descriptor will be loaded into the component it&#39;s attached to
    during initialisation.

    Parameters
    ----------
    name : str
        The name for this command group.

    Other Parameters
    ----------------
    *names : str
        Additional names for this command group passed as variable positional arguments.
    checks : typing.Optional[typing.Iterable[traits.CheckT]]
        An iterable of async or non-async check functions which should take
        one positional argument of type `Context` and return `builtins.bool`
        or raise `tanjun.errors.FailedCheck` where `FailedCheck` or `False` will
        prevent the command from being chosen for execution.
    hooks : typing.Optional[traits.Hooks]
        The execution hooks this command should be calling.
    parser : typing.Optional[traits.ParserDescriptor]
        A descriptor of the parser this command should use.

    Returns
    -------
    typing.Callable[[traits.CommandFunctionT], CommandGroupDescriptor]
        A decorator function for a command function.

    Examples
    --------
    Methods and attributes on the returned descriptor can be modified directly
    or using decorators in-order to fine tune the behaviour of this command
    (e.g. set a parser for the command) as shown below.

    ```python
    import tanjun

    class MyComponent(tanjun.components.Component):
        @tanjun.parsing.with_greedy_argument(&#34;content&#34;, converters=None)
        @tanjun.parsing.with_parser
        @tanjun.checks.with_owner_check
        @tanjun.components.as_group(&#34;help&#34;)
        async def help(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
            await ctx.message.reply(f&#34;`{content}` is not a valid help command&#34;)
    ```

    The `CommandGroupDescriptor.with_command` can be called on the returned
    descriptor in-order to add sub-commands to this group as shown below.

    ```python
    import tanjun

    class MyComponent(tanjun.components.Component):
        @tanjun.parsing.with_greedy_argument(&#34;content&#34;, converters=None)
        @tanjun.parsing.with_parser
        @tanjun.components.group(&#34;help&#34;)
        async def help(self, ctx: tanjun.traits.Context, /, content: str) -&gt; None:
            await ctx.message.reply(f&#34;`{content}` is not a valid help command&#34;)

        @help.with_command(&#34;me&#34;)
        async def help_me(self, ctx: tanjun.traits.Context) -&gt; None:
            await ctx.message.reply(f&#34;There is no reset for you, {ctx.message.author}&#34;)
    ```
    &#34;&#34;&#34;

    def decorator(function: traits.CommandFunctionT, /) -&gt; CommandGroupDescriptor:
        return CommandGroupDescriptor(checks, function, hooks, (name, *names), parser)

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.as_loader"><code class="name flex">
<span>def <span class="ident">as_loader</span></span>(<span>function: traits.LoadableT) ‑> Callable[[<a title="tanjun.Client" href="#tanjun.Client">Client</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Mark a function as being used to load Tanjun utilities from a module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>traits.LoadableT</code></dt>
<dd>The function used to load Tanjun utilities from the a module. This
should take one argument of type <code><a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a></code>, return nothing
and will be expected to initiate and add utilities such as components
to the provided client using it's protocol methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>traits.LoadableT</code></dt>
<dd>The decorated load function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_loader(function: traits.LoadableT) -&gt; traits.LoadableT:
    &#34;&#34;&#34;Mark a function as being used to load Tanjun utilities from a module.

    Parameters
    ----------
    function : traits.LoadableT
        The function used to load Tanjun utilities from the a module. This
        should take one argument of type `tanjun.traits.Client`, return nothing
        and will be expected to initiate and add utilities such as components
        to the provided client using it&#39;s protocol methods.

    Returns
    -------
    traits.LoadableT
        The decorated load function.
    &#34;&#34;&#34;
    return _LoadableDescriptor(function)</code></pre>
</details>
</dd>
<dt id="tanjun.parser_descriptor"><code class="name flex">
<span>def <span class="ident">parser_descriptor</span></span>(<span>*, parameters: typing.Optional[typing.Iterable[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>]] = None) ‑> tanjun.parsing.ParserDescriptor</span>
</code></dt>
<dd>
<div class="desc"><p>Build a shlex parser descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser_descriptor(*, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; ParserDescriptor:
    &#34;&#34;&#34;Build a shlex parser descriptor.&#34;&#34;&#34;
    return ParserDescriptor(parameters=parameters)</code></pre>
</details>
</dd>
<dt id="tanjun.verify_parameters"><code class="name flex">
<span>def <span class="ident">verify_parameters</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_parameters(command: CommandT, /) -&gt; CommandT:
    # TODO: implement this to verify the parameters of a command against the function signature
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_argument"><code class="name flex">
<span>def <span class="ident">with_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an argument to a command or command descriptor through a decorator call.</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_argument(&quot;command&quot;, converters=(int,), default=42)
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: int):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an argument to a command or command descriptor through a decorator call.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_argument(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT, /) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add a parameter to a command client without a parser.&#34;)

        argument = Argument(key, converters=converters, default=default, flags=flags)
        command.parser.add_parameter(argument)
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.with_author_permission_check"><code class="name flex">
<span>def <span class="ident">with_author_permission_check</span></span>(<span>permissions: typing.Union[permissions_.Permissions, int], /) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run if the author has certain permissions in the current channel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will always pass for commands triggered in DM channels.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>permissions</code></strong> :&ensp;<code>typing.Union[hikari.permissions.Permissions, builtins.int]</code></dt>
<dd>The permission(s) required for this command to run.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]</code></dt>
<dd>A command decorator function which adds the check.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_author_permission_check(
    permissions: typing.Union[permissions_.Permissions, int], /
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Only let a command run if the author has certain permissions in the current channel.

    !!! note
        This will always pass for commands triggered in DM channels.

    Parameters
    ----------
    permissions: typing.Union[hikari.permissions.Permissions, builtins.int]
        The permission(s) required for this command to run.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]
        A command decorator function which adds the check.
    &#34;&#34;&#34;

    def decorator(command: CommandT, /) -&gt; CommandT:
        command.add_check(AuthorPermissionCheck(permissions))
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.with_bot_permission_check"><code class="name flex">
<span>def <span class="ident">with_bot_permission_check</span></span>(<span>permissions: typing.Union[permissions_.Permissions, int], /) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run if we have certain permissions in the current channel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will always pass for commands triggered in DM channels.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>permissions</code></strong> :&ensp;<code>typing.Union[hikari.permissions.Permissions, builtins.int]</code></dt>
<dd>The permission(s) required for this command to run.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]</code></dt>
<dd>A command decorator function which adds the check.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_bot_permission_check(
    permissions: typing.Union[permissions_.Permissions, int], /
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Only let a command run if we have certain permissions in the current channel.

    !!! note
        This will always pass for commands triggered in DM channels.

    Parameters
    ----------
    permissions: typing.Union[hikari.permissions.Permissions, builtins.int]
        The permission(s) required for this command to run.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]
        A command decorator function which adds the check.
    &#34;&#34;&#34;

    def decorator(command: CommandT, /) -&gt; CommandT:
        command.add_check(BotPermissionsCheck(permissions))
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.with_dm_check"><code class="name flex">
<span>def <span class="ident">with_dm_check</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run in a DM channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>CommandT</code></dt>
<dd>The command to add this check to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandT</code></dt>
<dd>The command this check was added to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_dm_check(command: CommandT, /) -&gt; CommandT:
    &#34;&#34;&#34;Only let a command run in a DM channel.

    Parameters
    ----------
    command : CommandT
        The command to add this check to.

    Returns
    -------
    CommandT
        The command this check was added to.
    &#34;&#34;&#34;
    command.add_check(guild_check)
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_greedy_argument"><code class="name flex">
<span>def <span class="ident">with_greedy_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add a greedy argument to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A greedy argument will consume the remaining positional arguments and pass
them through to the converters as one joined string while also requiring
that at least one more positional argument is remaining unless a
default is set.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_greedy_argument(&quot;command&quot;, converters=(StringView,))
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: StringView):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_greedy_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A greedy argument will consume the remaining positional arguments and pass
        them through to the converters as one joined string while also requiring
        that at least one more positional argument is remaining unless a
        default is set.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_greedy_argument(&#34;command&#34;, converters=(StringView,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: StringView):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[GREEDY] = True
    return with_argument(key, converters=converters, default=default, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.with_guild_check"><code class="name flex">
<span>def <span class="ident">with_guild_check</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run in a guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>CommandT</code></dt>
<dd>The command to add this check to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandT</code></dt>
<dd>The command this check was added to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_guild_check(command: CommandT, /) -&gt; CommandT:
    &#34;&#34;&#34;Only let a command run in a guild channel.

    Parameters
    ----------
    command : CommandT
        The command to add this check to.

    Returns
    -------
    CommandT
        The command this check was added to.
    &#34;&#34;&#34;
    command.add_check(dm_check)
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_multi_argument"><code class="name flex">
<span>def <span class="ident">with_multi_argument</span></span>(<span>key: str, /, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, *, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add a greedy argument to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A multi argument will consume the remaining positional arguments and pass
them to the converters through multiple calls while also requiring that
at least one more positional argument is remaining unless a default is
set and passing through the results to the command's function as a
sequence.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>Order matters for positional arguments and since decorator execution
starts at the decorator closest to the command and goes upwards this
will decide where a positional argument is located in a command's
signature.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this argument (may be used to pass the result
of this argument to the command's function during execution).</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]]</code></dt>
<dd>An iterable of the converters this argument should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, if left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this will have no default.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this argument with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
argument.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_multi_argument(&quot;command&quot;, converters=(int,))
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_multi_argument(
    key: str,
    /,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    *,
    default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add a greedy argument to a command or command descriptor through a decorator call.

    !!! note
        A multi argument will consume the remaining positional arguments and pass
        them to the converters through multiple calls while also requiring that
        at least one more positional argument is remaining unless a default is
        set and passing through the results to the command&#39;s function as a
        sequence.

    !!! info
        Order matters for positional arguments and since decorator execution
        starts at the decorator closest to the command and goes upwards this
        will decide where a positional argument is located in a command&#39;s
        signature.

    Parameters
    ----------
    key : str
        The string identifier of this argument (may be used to pass the result
        of this argument to the command&#39;s function during execution).

    Other Parameters
    ----------------
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this argument should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    default : typing.Any
        The default value of this argument, if left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this will have no default.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this argument with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        argument.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_argument(&#34;command&#34;, converters=(int,))
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_argument(key, converters=converters, default=default, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.with_multi_option"><code class="name flex">
<span>def <span class="ident">with_multi_option</span></span>(<span>key: str, name: str, /, *names: str, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, default: typing.Any, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an multi-option to a command or command descriptor through a decorator call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A multi option will consume all the values provided for an option and
pass them through to the converters as an array of strings while also
requiring that at least one value is provided for the option unless
a default is set.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this option which will be used to pass the
result of this argument to the command's function during execution as
a keyword argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, unlike arguments this is required
for options.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Other names of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]]</code></dt>
<dd>An iterable of the converters this option should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>empty_value</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The value to use if this option is provided without a value. If left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this option will error if it's
provided without a value.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this option with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
option.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_multi_option(&quot;command&quot;, converters=(int,), default=())
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_multi_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an multi-option to a command or command descriptor through a decorator call.

    !!! note
        A multi option will consume all the values provided for an option and
        pass them through to the converters as an array of strings while also
        requiring that at least one value is provided for the option unless
        a default is set.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_multi_option(&#34;command&#34;, converters=(int,), default=())
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: typing.Sequence[int]):
        ...
    ```
    &#34;&#34;&#34;
    if flags is None:
        flags = {}

    flags[MULTI] = True
    return with_option(key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags)</code></pre>
</details>
</dd>
<dt id="tanjun.with_nsfw_check"><code class="name flex">
<span>def <span class="ident">with_nsfw_check</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run in a channel that's marked as nsfw.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>CommandT</code></dt>
<dd>The command to add this check to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandT</code></dt>
<dd>The command this check was added to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_nsfw_check(command: CommandT, /) -&gt; CommandT:
    &#34;&#34;&#34;Only let a command run in a channel that&#39;s marked as nsfw.

    Parameters
    ----------
    command : CommandT
        The command to add this check to.

    Returns
    -------
    CommandT
        The command this check was added to.
    &#34;&#34;&#34;
    command.add_check(nsfw_check)
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_option"><code class="name flex">
<span>def <span class="ident">with_option</span></span>(<span>key: str, name: str, /, *names: str, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, default: typing.Any, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None) ‑> Callable[[-CommandT], -CommandT]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an option to a command or command descriptor through a decorator call.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The string identifier of this option which will be used to pass the
result of this argument to the command's function during execution as
a keyword argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The default value of this argument, unlike arguments this is required
for options.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*names</code></strong> :&ensp;<code>str</code></dt>
<dd>Other names of this option used for identifying it in the parsed content.</dd>
<dt><strong><code>converters</code></strong> :&ensp;<code>typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]]</code></dt>
<dd>An iterable of the converters this option should use to handle values
passed to it during parsing, this may be left as `builtins.None to indicate
that the raw string value should be returned without conversion.</dd>
<dt><strong><code>empty_value</code></strong> :&ensp;<code>typing.Any</code></dt>
<dd>The value to use if this option is provided without a value. If left as
<code><a title="tanjun.traits.UNDEFINED_DEFAULT" href="traits.html#tanjun.traits.UNDEFINED_DEFAULT">UNDEFINED_DEFAULT</a></code> then this option will error if it's
provided without a value.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>typing.Optional[typing.MutableMapping[str, typing.Any]]</code></dt>
<dd>A mutable mapping of metadata flags to initiate this option with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Callable[[CommandT], CommandT]:</code></dt>
<dd>A command or command descriptor decorator function which will add this
option.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">import tanjun

@tanjun.parsing.with_option(&quot;command&quot;, converters=(int,), default=42)
@tanjun.parsing.with_parser
@tanjun.component.as_command(&quot;command&quot;)
async def command(self, ctx: tanjun.traits.Context, /, argument: int):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_option(
    key: str,
    name: str,
    /,
    *names: str,
    converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
    default: typing.Any,
    empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    flags: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
) -&gt; typing.Callable[[CommandT], CommandT]:
    &#34;&#34;&#34;Add an option to a command or command descriptor through a decorator call.

    Parameters
    ----------
    key : str
        The string identifier of this option which will be used to pass the
        result of this argument to the command&#39;s function during execution as
        a keyword argument.
    name : str
        The name of this option used for identifying it in the parsed content.
    default : typing.Any
        The default value of this argument, unlike arguments this is required
        for options.

    Other Parameters
    ----------------
    *names : str
        Other names of this option used for identifying it in the parsed content.
    converters : typing.Optional[typing.Iterable[traits.ConverterT]]
        An iterable of the converters this option should use to handle values
        passed to it during parsing, this may be left as `builtins.None to indicate
        that the raw string value should be returned without conversion.
    empty_value : typing.Any
        The value to use if this option is provided without a value. If left as
        `tanjun.traits.UNDEFINED_DEFAULT` then this option will error if it&#39;s
        provided without a value.
    flags : typing.Optional[typing.MutableMapping[str, typing.Any]]
        A mutable mapping of metadata flags to initiate this option with.

    Returns
    -------
    typing.Callable[[CommandT], CommandT]:
        A command or command descriptor decorator function which will add this
        option.

    Examples
    --------
    ```python
    import tanjun

    @tanjun.parsing.with_option(&#34;command&#34;, converters=(int,), default=42)
    @tanjun.parsing.with_parser
    @tanjun.component.as_command(&#34;command&#34;)
    async def command(self, ctx: tanjun.traits.Context, /, argument: int):
        ...
    ```
    &#34;&#34;&#34;

    def decorator(command: CommandT) -&gt; CommandT:
        if command.parser is None:
            raise ValueError(&#34;Cannot add an option to a command client without a parser.&#34;)

        option = Option(
            key, name, *names, converters=converters, default=default, empty_value=empty_value, flags=flags,
        )
        command.parser.add_parameter(option)
        return command

    return decorator</code></pre>
</details>
</dd>
<dt id="tanjun.with_owner_check"><code class="name flex">
<span>def <span class="ident">with_owner_check</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run if it's being triggered by one of the bot's owners.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is based on the owner(s) of the bot's application and will account
for team owners as well.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>CommandT</code></dt>
<dd>The command to add this check to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandT</code></dt>
<dd>The command this check was added to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_owner_check(command: CommandT, /) -&gt; CommandT:
    &#34;&#34;&#34;Only let a command run if it&#39;s being triggered by one of the bot&#39;s owners.

    !!! note
        This is based on the owner(s) of the bot&#39;s application and will account
        for team owners as well.

    Parameters
    ----------
    command : CommandT
        The command to add this check to.

    Returns
    -------
    CommandT
        The command this check was added to.
    &#34;&#34;&#34;
    command.add_check(ApplicationOwnerCheck())
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_parser"><code class="name flex">
<span>def <span class="ident">with_parser</span></span>(<span>command: CommandDescriptorT, /) ‑> ~CommandDescriptorT</span>
</code></dt>
<dd>
<div class="desc"><p>Add a shlex parser descriptor to a command descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_parser(command: CommandDescriptorT, /) -&gt; CommandDescriptorT:
    &#34;&#34;&#34;Add a shlex parser descriptor to a command descriptor.&#34;&#34;&#34;
    command.parser = parser_descriptor()
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_sfw_check"><code class="name flex">
<span>def <span class="ident">with_sfw_check</span></span>(<span>command: CommandT, /) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"><p>Only let a command run in a channel that's not marked as nsfw.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>CommandT</code></dt>
<dd>The command to add this check to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandT</code></dt>
<dd>The command this check was added to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_sfw_check(command: CommandT, /) -&gt; CommandT:
    &#34;&#34;&#34;Only let a command run in a channel that&#39;s not marked as nsfw.

    Parameters
    ----------
    command : CommandT
        The command to add this check to.

    Returns
    -------
    CommandT
        The command this check was added to.
    &#34;&#34;&#34;
    command.add_check(sfw_check)
    return command</code></pre>
</details>
</dd>
<dt id="tanjun.with_typed_parameters"><code class="name flex">
<span>def <span class="ident">with_typed_parameters</span></span>(<span>command: CommandT, /, *, ignore_self: bool) ‑> -CommandT</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_typed_parameters(command: CommandT, /, *, ignore_self: bool) -&gt; CommandT:
    # TODO: implement this to enable generating parameters from a function&#39;s signature.
    if command.parser is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no parser&#34;)

    if command.function is None:
        raise RuntimeError(&#34;Cannot generate parameters for a command with no function&#34;)

    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tanjun.Argument"><code class="flex name class">
<span>class <span class="ident">Argument</span></span>
<span>(</span><span>key: str, /, *, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.Mapping[str, typing.Any]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Argument(_Parameter, traits.Argument):
    __slots__: typing.Sequence[str] = ()

    def __init__(
        self,
        key: str,
        /,
        *,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
    ) -&gt; None:
        if flags and MULTI in flags and GREEDY in flags:
            raise ValueError(&#34;Argument cannot be both greed and multi.&#34;)

        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Argument:
        return Argument(
            self.key,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.parsing._Parameter</li>
<li><a title="tanjun.traits.Argument" href="traits.html#tanjun.traits.Argument">Argument</a></li>
<li><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="tanjun.ChannelConverter"><code class="flex name class">
<span>class <span class="ident">ChannelConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelConverter(BaseConverter[channels.GuildChannel]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; channels.GuildChannel:
        if ctx.client.cache_service:
            channel_id = ChannelIDParser.match_id(argument, message=&#34;No valid channel mention or ID  found&#34;)
            if channel := ctx.client.cache_service.cache.get_guild_channel(channel_id):
                return channel

        raise ValueError(&#34;Couldn&#39;t find channel&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (channels.GuildChannel,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.ChannelConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.ChannelConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.channels.GuildChannel</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; channels.GuildChannel:
    if ctx.client.cache_service:
        channel_id = ChannelIDParser.match_id(argument, message=&#34;No valid channel mention or ID  found&#34;)
        if channel := ctx.client.cache_service.cache.get_guild_channel(channel_id):
            return channel

    raise ValueError(&#34;Couldn&#39;t find channel&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.ChannelConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.ChannelConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.ChannelConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (channels.GuildChannel,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>dispatch: hikari_traits.DispatcherAware, rest: typing.Optional[hikari_traits.RESTAware] = None, shard: typing.Optional[hikari_traits.ShardAware] = None, cache: typing.Optional[hikari_traits.CacheAware] = None, /, *, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, mention_prefix: bool = True, modules: typing.Optional[typing.Iterable[typing.Union[pathlib.Path, str]]] = None, prefixes: typing.Optional[typing.Iterable[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(traits.Client):
    __slots__: typing.Sequence[str] = (
        &#34;_cache&#34;,
        &#34;_checks&#34;,
        &#34;_components&#34;,
        &#34;_dispatch&#34;,
        &#34;_grab_mention_prefix&#34;,
        &#34;hooks&#34;,
        &#34;_metadata&#34;,
        &#34;_prefixes&#34;,
        &#34;_rest&#34;,
        &#34;_shards&#34;,
    )

    def __init__(
        self,
        dispatch: hikari_traits.DispatcherAware,
        rest: typing.Optional[hikari_traits.RESTAware] = None,
        shard: typing.Optional[hikari_traits.ShardAware] = None,
        cache: typing.Optional[hikari_traits.CacheAware] = None,
        /,
        *,
        checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
        hooks: typing.Optional[traits.Hooks] = None,
        mention_prefix: bool = True,
        modules: typing.Optional[typing.Iterable[typing.Union[pathlib.Path, str]]] = None,
        prefixes: typing.Optional[typing.Iterable[str]] = None,
    ) -&gt; None:
        if rest is not None:
            pass

        elif isinstance(cache, hikari_traits.RESTAware):
            rest = cache

        elif isinstance(dispatch, hikari_traits.RESTAware):
            rest = dispatch

        elif isinstance(shard, hikari_traits.RESTAware):
            rest = shard  # type: ignore[unreachable]

        else:
            raise ValueError(&#34;Missing RESTAware client implementation.&#34;)

        if shard is not None:
            pass

        elif isinstance(cache, hikari_traits.ShardAware):
            shard = cache

        elif isinstance(dispatch, hikari_traits.ShardAware):
            shard = dispatch

        elif isinstance(rest, hikari_traits.ShardAware):
            shard = rest

        else:
            raise ValueError(&#34;Missing ShardAware client implementation.&#34;)

        # Unlike `rest`, no provided Cache implementation just means this runs stateless.
        if cache is not None:
            pass

        elif isinstance(dispatch, hikari_traits.CacheAware):
            cache = dispatch

        elif isinstance(rest, hikari_traits.CacheAware):
            cache = rest

        elif isinstance(shard, hikari_traits.CacheAware):  # type: ignore[unreachable]
            cache = shard
        # TODO: logging or something to indicate this is running statelessly rather than statefully.

        self._checks: typing.MutableSet[traits.CheckT] = {self.check_human, *(checks or ())}
        self._cache = cache
        self._components: typing.MutableSet[traits.Component] = set()
        self._dispatch = dispatch
        self._grab_mention_prefix = mention_prefix
        self.hooks = hooks
        self._metadata: typing.MutableMapping[typing.Any, typing.Any] = {}
        self._prefixes = set(prefixes) if prefixes else set()
        self._rest = rest
        self._shards = shard
        self._dispatch.dispatcher.subscribe(lifetime_events.StartingEvent, self._on_starting_event)
        self._dispatch.dispatcher.subscribe(lifetime_events.StoppingEvent, self._on_stopping_event)

        if modules:
            self.load_from_modules(modules)

    async def __aenter__(self) -&gt; Client:
        await self.open()
        return self

    async def __aexit__(
        self,
        exception_type: typing.Optional[typing.Type[BaseException]],
        exception: typing.Optional[BaseException],
        exception_traceback: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    def __repr__(self) -&gt; str:
        return f&#34;CommandClient &lt;{type(self).__name__!r}, {len(self._components)} components, {self._prefixes}&gt;&#34;

    @property
    def cache_service(self) -&gt; typing.Optional[hikari_traits.CacheAware]:
        return self._cache

    @property
    def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
        return frozenset(self._checks)

    @property
    def components(self) -&gt; typing.AbstractSet[traits.Component]:
        return frozenset(self._components)

    @property
    def dispatch_service(self) -&gt; hikari_traits.DispatcherAware:
        return self._dispatch

    @property
    def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
        return self._metadata

    @property
    def prefixes(self) -&gt; typing.AbstractSet[str]:
        return frozenset(self._prefixes)

    @property
    def rest_service(self) -&gt; hikari_traits.RESTAware:
        return self._rest

    @property
    def shard_service(self) -&gt; hikari_traits.ShardAware:
        return self._shards

    async def _on_starting_event(self, _: lifetime_events.StartingEvent, /) -&gt; None:
        await self.open()

    async def _on_stopping_event(self, _: lifetime_events.StoppingEvent, /) -&gt; None:
        await self.close()

    def add_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.add(check)

    def remove_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.remove(check)

    async def check(self, ctx: traits.Context, /) -&gt; bool:
        return await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks)

    def add_component(self, component: traits.Component, /) -&gt; None:
        component.bind_client(self)
        self._components.add(component)

    def remove_component(self, component: traits.Component, /) -&gt; None:
        self._components.remove(component)

    def add_prefix(self, prefix: str, /) -&gt; None:
        self._prefixes.add(prefix)

    def remove_prefix(self, prefix: str, /) -&gt; None:
        self._prefixes.remove(prefix)

    async def check_context(self, ctx: traits.Context, /) -&gt; typing.AsyncIterator[traits.FoundCommand]:
        async for value in utilities.async_chain(component.check_context(ctx) for component in self._components):
            yield value

    @staticmethod
    def check_human(ctx: traits.Context, /) -&gt; bool:
        return not ctx.message.author.is_bot and ctx.message.webhook_id is None

    def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
        yield from itertools.chain.from_iterable(component.check_name(name) for component in self._components)

    async def check_prefix(self, content: str, /) -&gt; typing.Optional[str]:
        for prefix in self._prefixes:
            if content.startswith(prefix):
                return prefix

        return None

    async def close(self, *, deregister_listener: bool = True) -&gt; None:
        self._dispatch.dispatcher.unsubscribe(message_events.MessageCreateEvent, self.on_message_create)

        if deregister_listener:
            await asyncio.gather(*(component.close() for component in self._components))

    async def open(self, *, register_listener: bool = True) -&gt; None:
        await asyncio.gather(*(component.open() for component in self._components))

        if self._grab_mention_prefix:
            retry = backoff.Backoff(max_retries=4, maximum=30)

            async for _ in retry:
                try:
                    user = await self._rest.rest.fetch_my_user()
                    break

                except hikari_errors.RateLimitedError as exc:
                    if exc.retry_after &gt; 30:
                        raise

                    retry.set_next_backoff(exc.retry_after)

                except hikari_errors.InternalServerError:
                    continue

            else:
                user = await self._rest.rest.fetch_my_user()

            self._grab_mention_prefix = False
            self._prefixes.add(f&#34;&lt;@{user.id}&gt;&#34;)
            self._prefixes.add(f&#34;&lt;@!{user.id}&gt;&#34;)

        if register_listener:
            self._dispatch.dispatcher.subscribe(message_events.MessageCreateEvent, self.on_message_create)

    def load_from_modules(self, modules: typing.Iterable[typing.Union[str, pathlib.Path]]) -&gt; None:
        for module_path in modules:
            if isinstance(module_path, str):
                module = importlib.import_module(module_path)

            else:
                spec = importlib.util.spec_from_file_location(
                    module_path.name.rsplit(&#34;.&#34;, 1)[0], str(module_path.absolute())
                )
                module = importlib.util.module_from_spec(spec)

                if spec.loader is None:
                    raise RuntimeError(f&#34;Invalid module provided {module_path}&#34;)

                # The type shedding is wrong here
                spec.loader.exec_module(module)  # type: ignore[attr-defined]

            for _, member in inspect.getmembers(module):
                if isinstance(member, traits.LoadableDescriptor):
                    member.load_function(self)

    async def on_message_create(self, event: message_events.MessageCreateEvent) -&gt; None:
        if event.message.content is None:
            return

        if (prefix := await self.check_prefix(event.message.content)) is None:
            return

        content = event.message.content.lstrip()[len(prefix) :].lstrip()
        ctx = context.Context(self, content=content, message=event.message, triggering_prefix=prefix)

        if not await self.check(ctx):
            return

        hooks = {self.hooks,} if self.hooks else set()

        for component in self._components:
            if await component.execute(ctx, hooks=hooks):
                break</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.Client.check_human"><code class="name flex">
<span>def <span class="ident">check_human</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def check_human(ctx: traits.Context, /) -&gt; bool:
    return not ctx.message.author.is_bot and ctx.message.webhook_id is None</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.Client.cache_service"><code class="name">var <span class="ident">cache_service</span> : Union[hikari.traits.CacheAware, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cache_service(self) -&gt; typing.Optional[hikari_traits.CacheAware]:
    return self._cache</code></pre>
</details>
</dd>
<dt id="tanjun.Client.checks"><code class="name">var <span class="ident">checks</span> : AbstractSet[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
    return frozenset(self._checks)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.components"><code class="name">var <span class="ident">components</span> : AbstractSet[<a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def components(self) -&gt; typing.AbstractSet[traits.Component]:
    return frozenset(self._components)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.dispatch_service"><code class="name">var <span class="ident">dispatch_service</span> : hikari.traits.DispatcherAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dispatch_service(self) -&gt; hikari_traits.DispatcherAware:
    return self._dispatch</code></pre>
</details>
</dd>
<dt id="tanjun.Client.hooks"><code class="name">var <span class="ident">hooks</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Client.metadata"><code class="name">var <span class="ident">metadata</span> : MutableMapping[Any, Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
    return self._metadata</code></pre>
</details>
</dd>
<dt id="tanjun.Client.prefixes"><code class="name">var <span class="ident">prefixes</span> : AbstractSet[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prefixes(self) -&gt; typing.AbstractSet[str]:
    return frozenset(self._prefixes)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.rest_service"><code class="name">var <span class="ident">rest_service</span> : hikari.traits.RESTAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rest_service(self) -&gt; hikari_traits.RESTAware:
    return self._rest</code></pre>
</details>
</dd>
<dt id="tanjun.Client.shard_service"><code class="name">var <span class="ident">shard_service</span> : hikari.traits.ShardAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shard_service(self) -&gt; hikari_traits.ShardAware:
    return self._shards</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.Client.add_check"><code class="name flex">
<span>def <span class="ident">add_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.add(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.add_component"><code class="name flex">
<span>def <span class="ident">add_component</span></span>(<span>self, component: <a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_component(self, component: traits.Component, /) -&gt; None:
    component.bind_client(self)
    self._components.add(component)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.add_prefix"><code class="name flex">
<span>def <span class="ident">add_prefix</span></span>(<span>self, prefix: str, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_prefix(self, prefix: str, /) -&gt; None:
    self._prefixes.add(prefix)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.check"><code class="name flex">
<span>async def <span class="ident">check</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check(self, ctx: traits.Context, /) -&gt; bool:
    return await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.check_context"><code class="name flex">
<span>async def <span class="ident">check_context</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /) ‑> AsyncIterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_context(self, ctx: traits.Context, /) -&gt; typing.AsyncIterator[traits.FoundCommand]:
    async for value in utilities.async_chain(component.check_context(ctx) for component in self._components):
        yield value</code></pre>
</details>
</dd>
<dt id="tanjun.Client.check_name"><code class="name flex">
<span>def <span class="ident">check_name</span></span>(<span>self, name: str, /) ‑> Iterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
    yield from itertools.chain.from_iterable(component.check_name(name) for component in self._components)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.check_prefix"><code class="name flex">
<span>async def <span class="ident">check_prefix</span></span>(<span>self, content: str, /) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_prefix(self, content: str, /) -&gt; typing.Optional[str]:
    for prefix in self._prefixes:
        if content.startswith(prefix):
            return prefix

    return None</code></pre>
</details>
</dd>
<dt id="tanjun.Client.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self, *, deregister_listener: bool = True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self, *, deregister_listener: bool = True) -&gt; None:
    self._dispatch.dispatcher.unsubscribe(message_events.MessageCreateEvent, self.on_message_create)

    if deregister_listener:
        await asyncio.gather(*(component.close() for component in self._components))</code></pre>
</details>
</dd>
<dt id="tanjun.Client.load_from_modules"><code class="name flex">
<span>def <span class="ident">load_from_modules</span></span>(<span>self, modules: typing.Iterable[typing.Union[str, pathlib.Path]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_modules(self, modules: typing.Iterable[typing.Union[str, pathlib.Path]]) -&gt; None:
    for module_path in modules:
        if isinstance(module_path, str):
            module = importlib.import_module(module_path)

        else:
            spec = importlib.util.spec_from_file_location(
                module_path.name.rsplit(&#34;.&#34;, 1)[0], str(module_path.absolute())
            )
            module = importlib.util.module_from_spec(spec)

            if spec.loader is None:
                raise RuntimeError(f&#34;Invalid module provided {module_path}&#34;)

            # The type shedding is wrong here
            spec.loader.exec_module(module)  # type: ignore[attr-defined]

        for _, member in inspect.getmembers(module):
            if isinstance(member, traits.LoadableDescriptor):
                member.load_function(self)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.on_message_create"><code class="name flex">
<span>async def <span class="ident">on_message_create</span></span>(<span>self, event: message_events.MessageCreateEvent) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_message_create(self, event: message_events.MessageCreateEvent) -&gt; None:
    if event.message.content is None:
        return

    if (prefix := await self.check_prefix(event.message.content)) is None:
        return

    content = event.message.content.lstrip()[len(prefix) :].lstrip()
    ctx = context.Context(self, content=content, message=event.message, triggering_prefix=prefix)

    if not await self.check(ctx):
        return

    hooks = {self.hooks,} if self.hooks else set()

    for component in self._components:
        if await component.execute(ctx, hooks=hooks):
            break</code></pre>
</details>
</dd>
<dt id="tanjun.Client.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self, *, register_listener: bool = True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self, *, register_listener: bool = True) -&gt; None:
    await asyncio.gather(*(component.open() for component in self._components))

    if self._grab_mention_prefix:
        retry = backoff.Backoff(max_retries=4, maximum=30)

        async for _ in retry:
            try:
                user = await self._rest.rest.fetch_my_user()
                break

            except hikari_errors.RateLimitedError as exc:
                if exc.retry_after &gt; 30:
                    raise

                retry.set_next_backoff(exc.retry_after)

            except hikari_errors.InternalServerError:
                continue

        else:
            user = await self._rest.rest.fetch_my_user()

        self._grab_mention_prefix = False
        self._prefixes.add(f&#34;&lt;@{user.id}&gt;&#34;)
        self._prefixes.add(f&#34;&lt;@!{user.id}&gt;&#34;)

    if register_listener:
        self._dispatch.dispatcher.subscribe(message_events.MessageCreateEvent, self.on_message_create)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.remove_check"><code class="name flex">
<span>def <span class="ident">remove_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.remove(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.remove_component"><code class="name flex">
<span>def <span class="ident">remove_component</span></span>(<span>self, component: <a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_component(self, component: traits.Component, /) -&gt; None:
    self._components.remove(component)</code></pre>
</details>
</dd>
<dt id="tanjun.Client.remove_prefix"><code class="name flex">
<span>def <span class="ident">remove_prefix</span></span>(<span>self, prefix: str, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_prefix(self, prefix: str, /) -&gt; None:
    self._prefixes.remove(prefix)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.ColorConverter"><code class="flex name class">
<span>class <span class="ident">ColorConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColorConverter(BaseConverter[colors.Color]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; typing.Any:
        values = argument.split(&#34; &#34;)
        if all(value.isdigit() for value in values):
            return colors.Color.of(*map(int, values))

        return colors.Color.of(*values)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (colors.Color,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.ColorConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.ColorConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>_: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, _: traits.Context, argument: str, /) -&gt; typing.Any:
    values = argument.split(&#34; &#34;)
    if all(value.isdigit() for value in values):
        return colors.Color.of(*map(int, values))

    return colors.Color.of(*values)</code></pre>
</details>
</dd>
<dt id="tanjun.ColorConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.NONE</code></pre>
</details>
</dd>
<dt id="tanjun.ColorConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.ColorConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (colors.Color,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.Command"><code class="flex name class">
<span>class <span class="ident">Command</span></span>
<span>(</span><span>function: traits.CommandFunctionT, name: str, /, *names: str, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, metadata: typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None, parser: typing.Optional[<a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Command(traits.ExecutableCommand):
    __slots__: typing.Sequence[str] = (
        &#34;_checks&#34;,
        &#34;_component&#34;,
        &#34;_function&#34;,
        &#34;hooks&#34;,
        &#34;_metadata&#34;,
        &#34;_names&#34;,
        &#34;parent&#34;,
        &#34;parser&#34;,
    )

    def __init__(
        self,
        function: traits.CommandFunctionT,
        name: str,
        /,
        *names: str,
        checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
        hooks: typing.Optional[traits.Hooks] = None,
        metadata: typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None,
        parser: typing.Optional[traits.Parser] = None,
    ) -&gt; None:
        self._checks = set(checks) if checks else set()
        self._component: typing.Optional[traits.Component] = None
        self._function = function
        self.hooks: traits.Hooks = hooks or hooks_.Hooks()
        self._metadata = metadata or {}
        self._names = {name, *names}
        self.parent: typing.Optional[traits.ExecutableCommandGroup] = None
        self.parser = parser

    def __repr__(self) -&gt; str:
        return f&#34;Command &lt;{self._names}&gt;&#34;

    @property
    def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
        return frozenset(self._checks)

    @property
    def component(self) -&gt; typing.Optional[traits.Component]:
        return self._component

    @property
    def function(self) -&gt; traits.CommandFunctionT:
        return self._function

    @property
    def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
        return self._metadata

    @property
    def names(self) -&gt; typing.AbstractSet[str]:
        return frozenset(self._names)

    def add_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.add(check)

    def remove_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.remove(check)

    def with_check(self, check: traits.CheckT, /) -&gt; traits.CheckT:
        self.add_check(check)
        return check

    async def check_context(
        self, ctx: traits.Context, /, *, name_prefix: str = &#34;&#34;
    ) -&gt; typing.AsyncIterator[traits.FoundCommand]:
        if found := next(self.check_name(ctx.content[len(name_prefix) :].lstrip()), None):
            if await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks):
                yield found

    def add_name(self, name: str, /) -&gt; None:
        self._names.add(name)

    def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
        for own_name in self._names:
            # Here we enforce that a name must either be at the end of content or be followed by a space. This helps
            # avoid issues with ambiguous naming where a command with the names &#34;name&#34; and &#34;names&#34; may sometimes hit
            # the former before the latter when triggered with the latter, leading to the command potentially being
            # inconsistently parsed.
            if name.startswith(own_name) and (name == own_name or name[len(own_name)] == &#34; &#34;):
                yield FoundCommand(self, own_name)
                break

    def remove_name(self, name: str, /) -&gt; None:
        self._names.remove(name)

    def bind_client(self, client: traits.Client, /) -&gt; None:
        if self.parser:
            self.parser.bind_client(client)

    def bind_component(self, component: traits.Component, /) -&gt; None:
        pass

    async def execute(
        self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
    ) -&gt; bool:
        try:
            if await self.hooks.trigger_pre_execution(ctx, hooks=hooks) is False:
                return True

            if self.parser is not None:
                args, kwargs = await self.parser.parse(ctx)

            else:
                args = []
                kwargs = {}

            await self._function(ctx, *args, **kwargs)

        except errors.CommandError as exc:
            if not exc.message:
                return True

            response = exc.message if len(exc.message) &lt;= 2000 else exc.message[:1997] + &#34;...&#34;
            retry = backoff.Backoff(max_retries=5, maximum=2)
            # TODO: preemptive cache based permission checks before throwing to the REST gods.
            async for _ in retry:
                try:
                    await ctx.message.reply(content=response)

                except hikari_errors.RateLimitedError as retry_error:
                    if retry_error.retry_after &gt; 4:
                        raise

                    retry.set_next_backoff(retry_error.retry_after)  # TODO: check if this is too large.

                except hikari_errors.InternalServerError:
                    continue

                except (hikari_errors.ForbiddenError, hikari_errors.NotFoundError):
                    break

                else:
                    break

        except errors.ParserError as exc:
            await self.hooks.trigger_parser_error(ctx, exc, hooks=hooks)

        except Exception as exc:
            await self.hooks.trigger_error(ctx, exc, hooks=hooks)
            raise

        else:
            # TODO: how should this be handled around CommandError?
            await self.hooks.trigger_success(ctx, hooks=hooks)

        finally:
            await self.hooks.trigger_post_execution(ctx, hooks=hooks)

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a></li>
<li><a title="tanjun.traits.Executable" href="traits.html#tanjun.traits.Executable">Executable</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tanjun.commands.CommandGroup" href="commands.html#tanjun.commands.CommandGroup">CommandGroup</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.Command.checks"><code class="name">var <span class="ident">checks</span> : AbstractSet[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
    return frozenset(self._checks)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.component"><code class="name">var <span class="ident">component</span> : Union[<a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def component(self) -&gt; typing.Optional[traits.Component]:
    return self._component</code></pre>
</details>
</dd>
<dt id="tanjun.Command.function"><code class="name">var <span class="ident">function</span> : Callable[..., Coroutine[Any, Any, Any]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function(self) -&gt; traits.CommandFunctionT:
    return self._function</code></pre>
</details>
</dd>
<dt id="tanjun.Command.hooks"><code class="name">var <span class="ident">hooks</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Command.metadata"><code class="name">var <span class="ident">metadata</span> : MutableMapping[Any, Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
    return self._metadata</code></pre>
</details>
</dd>
<dt id="tanjun.Command.names"><code class="name">var <span class="ident">names</span> : AbstractSet[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def names(self) -&gt; typing.AbstractSet[str]:
    return frozenset(self._names)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Command.parser"><code class="name">var <span class="ident">parser</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.Command.add_check"><code class="name flex">
<span>def <span class="ident">add_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.add(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.add_name"><code class="name flex">
<span>def <span class="ident">add_name</span></span>(<span>self, name: str, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_name(self, name: str, /) -&gt; None:
    self._names.add(name)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.bind_client"><code class="name flex">
<span>def <span class="ident">bind_client</span></span>(<span>self, client: <a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_client(self, client: traits.Client, /) -&gt; None:
    if self.parser:
        self.parser.bind_client(client)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.bind_component"><code class="name flex">
<span>def <span class="ident">bind_component</span></span>(<span>self, component: <a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_component(self, component: traits.Component, /) -&gt; None:
    pass</code></pre>
</details>
</dd>
<dt id="tanjun.Command.check_context"><code class="name flex">
<span>async def <span class="ident">check_context</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /, *, name_prefix: str = '') ‑> AsyncIterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_context(
    self, ctx: traits.Context, /, *, name_prefix: str = &#34;&#34;
) -&gt; typing.AsyncIterator[traits.FoundCommand]:
    if found := next(self.check_name(ctx.content[len(name_prefix) :].lstrip()), None):
        if await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks):
            yield found</code></pre>
</details>
</dd>
<dt id="tanjun.Command.check_name"><code class="name flex">
<span>def <span class="ident">check_name</span></span>(<span>self, name: str, /) ‑> Iterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
    for own_name in self._names:
        # Here we enforce that a name must either be at the end of content or be followed by a space. This helps
        # avoid issues with ambiguous naming where a command with the names &#34;name&#34; and &#34;names&#34; may sometimes hit
        # the former before the latter when triggered with the latter, leading to the command potentially being
        # inconsistently parsed.
        if name.startswith(own_name) and (name == own_name or name[len(own_name)] == &#34; &#34;):
            yield FoundCommand(self, own_name)
            break</code></pre>
</details>
</dd>
<dt id="tanjun.Command.execute"><code class="name flex">
<span>async def <span class="ident">execute</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /, *, hooks: typing.Optional[typing.MutableSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute(
    self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
) -&gt; bool:
    try:
        if await self.hooks.trigger_pre_execution(ctx, hooks=hooks) is False:
            return True

        if self.parser is not None:
            args, kwargs = await self.parser.parse(ctx)

        else:
            args = []
            kwargs = {}

        await self._function(ctx, *args, **kwargs)

    except errors.CommandError as exc:
        if not exc.message:
            return True

        response = exc.message if len(exc.message) &lt;= 2000 else exc.message[:1997] + &#34;...&#34;
        retry = backoff.Backoff(max_retries=5, maximum=2)
        # TODO: preemptive cache based permission checks before throwing to the REST gods.
        async for _ in retry:
            try:
                await ctx.message.reply(content=response)

            except hikari_errors.RateLimitedError as retry_error:
                if retry_error.retry_after &gt; 4:
                    raise

                retry.set_next_backoff(retry_error.retry_after)  # TODO: check if this is too large.

            except hikari_errors.InternalServerError:
                continue

            except (hikari_errors.ForbiddenError, hikari_errors.NotFoundError):
                break

            else:
                break

    except errors.ParserError as exc:
        await self.hooks.trigger_parser_error(ctx, exc, hooks=hooks)

    except Exception as exc:
        await self.hooks.trigger_error(ctx, exc, hooks=hooks)
        raise

    else:
        # TODO: how should this be handled around CommandError?
        await self.hooks.trigger_success(ctx, hooks=hooks)

    finally:
        await self.hooks.trigger_post_execution(ctx, hooks=hooks)

    return True</code></pre>
</details>
</dd>
<dt id="tanjun.Command.remove_check"><code class="name flex">
<span>def <span class="ident">remove_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.remove(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.remove_name"><code class="name flex">
<span>def <span class="ident">remove_name</span></span>(<span>self, name: str, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_name(self, name: str, /) -&gt; None:
    self._names.remove(name)</code></pre>
</details>
</dd>
<dt id="tanjun.Command.with_check"><code class="name flex">
<span>def <span class="ident">with_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_check(self, check: traits.CheckT, /) -&gt; traits.CheckT:
    self.add_check(check)
    return check</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.CommandError"><code class="flex name class">
<span>class <span class="ident">CommandError</span></span>
<span>(</span><span>message: typing.Optional[str], /)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised to end command execution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>If this is a non-empty string then this message should will be sent as
a response to the message that triggered the current command otherwise
<code>builtins.None</code> or <code>""</code> will silently end command execution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandError(TanjunError):
    &#34;&#34;&#34;Error raised to end command execution.

    Parameters
    ----------
    message : typing.Optional[str]
        If this is a non-empty string then this message should will be sent as
        a response to the message that triggered the current command otherwise
        `builtins.None` or `&#34;&#34;` will silently end command execution.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;message&#34;,)

    # None or empty string == no response
    message: typing.Optional[str]
    &#34;&#34;&#34;The response error message.

    If this is an empty string or `builtins.None` then this will silently end
    command execution otherwise Tanjun will try to send the string message in
    response.
    &#34;&#34;&#34;

    def __init__(self, message: typing.Optional[str], /) -&gt; None:
        if message and len(message) &gt; 2000:
            raise ValueError(&#34;Error message cannot be over 2_000 characters long.&#34;)

        self.message = message

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__} &lt;{self.message}&gt;&#34;

    def __str__(self) -&gt; str:
        return self.message or &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.CommandError.message"><code class="name">var <span class="ident">message</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>The response error message.</p>
<p>If this is an empty string or <code>builtins.None</code> then this will silently end
command execution otherwise Tanjun will try to send the string message in
response.</p></div>
</dd>
</dl>
</dd>
<dt id="tanjun.CommandGroup"><code class="flex name class">
<span>class <span class="ident">CommandGroup</span></span>
<span>(</span><span>function: traits.CommandFunctionT, name: str, /, *names: str, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, metadata: typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None, parser: typing.Optional[<a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandGroup(Command, traits.ExecutableCommandGroup):
    __slots__: typing.Sequence[str] = (&#34;_commands&#34;,)

    def __init__(
        self,
        function: traits.CommandFunctionT,
        name: str,
        /,
        *names: str,
        checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
        hooks: typing.Optional[traits.Hooks] = None,
        metadata: typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None,
        parser: typing.Optional[traits.Parser] = None,
    ) -&gt; None:
        super().__init__(function, name, *names, checks=checks, hooks=hooks, metadata=metadata, parser=parser)
        self._commands: typing.MutableSet[traits.ExecutableCommand] = set()

    def __repr__(self) -&gt; str:
        return f&#34;CommandGroup &lt;{len(self._commands)}: {self._names}&gt;&#34;

    @property
    def commands(self) -&gt; typing.AbstractSet[traits.ExecutableCommand]:
        return frozenset(self._commands)

    def add_command(self, command: traits.ExecutableCommand, /) -&gt; None:
        command.parent = self
        self._commands.add(command)

    def remove_command(self, command: traits.ExecutableCommand, /) -&gt; None:
        command.parent = None
        self._commands.remove(command)

    def with_command(
        self,
        name: str,
        /,
        *names: str,
        checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
        hooks: typing.Optional[traits.Hooks] = None,
        parser: typing.Optional[traits.Parser] = None,
    ) -&gt; typing.Callable[[traits.CommandFunctionT], traits.CommandFunctionT]:
        def decorator(function: traits.CommandFunctionT, /) -&gt; traits.CommandFunctionT:
            self.add_command(Command(function, name, *names, checks=checks, hooks=hooks, parser=parser))
            return function

        return decorator

    def bind_client(self, client: traits.Client, /) -&gt; None:
        super().bind_client(client)
        for command in self._commands:
            command.bind_client(client)

    # I sure hope this plays well with command group recursion cause I am waaaaaaaaaaaaaay too lazy to test that myself.
    async def execute(
        self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
    ) -&gt; bool:
        if ctx.message.content is None:
            raise ValueError(&#34;Cannot execute a command with a contentless message&#34;)

        if self.hooks and hooks:
            hooks.add(self.hooks)

        elif self.hooks:
            hooks = {self.hooks}

        for command in self._commands:
            async for result in command.check_context(ctx):
                # triggering_prefix should never be None here but for the sake of covering all cases if it is then we
                # assume an empty string.
                # If triggering_name is None then we assume an empty string for that as well.
                content = ctx.message.content.lstrip()[len(ctx.triggering_prefix or &#34;&#34;) :].lstrip()[
                    len(ctx.triggering_name or &#34;&#34;) :
                ]
                space_len = len(content) - len(content.lstrip())
                ctx.triggering_name = (ctx.triggering_name or &#34;&#34;) + (&#34; &#34; * space_len) + result.name
                ctx.content = ctx.content[space_len + len(result.name) :].lstrip()
                await result.command.execute(ctx, hooks=hooks)
                return True

        return await super().execute(ctx, hooks=hooks)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.commands.Command" href="commands.html#tanjun.commands.Command">Command</a></li>
<li><a title="tanjun.traits.ExecutableCommandGroup" href="traits.html#tanjun.traits.ExecutableCommandGroup">ExecutableCommandGroup</a></li>
<li><a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a></li>
<li><a title="tanjun.traits.Executable" href="traits.html#tanjun.traits.Executable">Executable</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.CommandGroup.commands"><code class="name">var <span class="ident">commands</span> : AbstractSet[<a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; typing.AbstractSet[traits.ExecutableCommand]:
    return frozenset(self._commands)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.CommandGroup.add_command"><code class="name flex">
<span>def <span class="ident">add_command</span></span>(<span>self, command: <a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_command(self, command: traits.ExecutableCommand, /) -&gt; None:
    command.parent = self
    self._commands.add(command)</code></pre>
</details>
</dd>
<dt id="tanjun.CommandGroup.bind_client"><code class="name flex">
<span>def <span class="ident">bind_client</span></span>(<span>self, client: <a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_client(self, client: traits.Client, /) -&gt; None:
    super().bind_client(client)
    for command in self._commands:
        command.bind_client(client)</code></pre>
</details>
</dd>
<dt id="tanjun.CommandGroup.execute"><code class="name flex">
<span>async def <span class="ident">execute</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /, *, hooks: typing.Optional[typing.MutableSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute(
    self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
) -&gt; bool:
    if ctx.message.content is None:
        raise ValueError(&#34;Cannot execute a command with a contentless message&#34;)

    if self.hooks and hooks:
        hooks.add(self.hooks)

    elif self.hooks:
        hooks = {self.hooks}

    for command in self._commands:
        async for result in command.check_context(ctx):
            # triggering_prefix should never be None here but for the sake of covering all cases if it is then we
            # assume an empty string.
            # If triggering_name is None then we assume an empty string for that as well.
            content = ctx.message.content.lstrip()[len(ctx.triggering_prefix or &#34;&#34;) :].lstrip()[
                len(ctx.triggering_name or &#34;&#34;) :
            ]
            space_len = len(content) - len(content.lstrip())
            ctx.triggering_name = (ctx.triggering_name or &#34;&#34;) + (&#34; &#34; * space_len) + result.name
            ctx.content = ctx.content[space_len + len(result.name) :].lstrip()
            await result.command.execute(ctx, hooks=hooks)
            return True

    return await super().execute(ctx, hooks=hooks)</code></pre>
</details>
</dd>
<dt id="tanjun.CommandGroup.remove_command"><code class="name flex">
<span>def <span class="ident">remove_command</span></span>(<span>self, command: <a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_command(self, command: traits.ExecutableCommand, /) -&gt; None:
    command.parent = None
    self._commands.remove(command)</code></pre>
</details>
</dd>
<dt id="tanjun.CommandGroup.with_command"><code class="name flex">
<span>def <span class="ident">with_command</span></span>(<span>self, name: str, /, *names: str, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None, parser: typing.Optional[<a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a>] = None) ‑> Callable[[Callable[..., Coroutine[Any, Any, Any]]], Callable[..., Coroutine[Any, Any, Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_command(
    self,
    name: str,
    /,
    *names: str,
    checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
    hooks: typing.Optional[traits.Hooks] = None,
    parser: typing.Optional[traits.Parser] = None,
) -&gt; typing.Callable[[traits.CommandFunctionT], traits.CommandFunctionT]:
    def decorator(function: traits.CommandFunctionT, /) -&gt; traits.CommandFunctionT:
        self.add_command(Command(function, name, *names, checks=checks, hooks=hooks, parser=parser))
        return function

    return decorator</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tanjun.commands.Command" href="commands.html#tanjun.commands.Command">Command</a></b></code>:
<ul class="hlist">
<li><code><a title="tanjun.commands.Command.hooks" href="commands.html#tanjun.commands.Command.hooks">hooks</a></code></li>
<li><code><a title="tanjun.commands.Command.parent" href="commands.html#tanjun.commands.Command.parent">parent</a></code></li>
<li><code><a title="tanjun.commands.Command.parser" href="commands.html#tanjun.commands.Command.parser">parser</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tanjun.Component"><code class="flex name class">
<span>class <span class="ident">Component</span></span>
<span>(</span><span>*, checks: typing.Optional[typing.Iterable[<a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>]] = None, hooks: typing.Optional[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Component(traits.Component):
    started: bool
    &#34;&#34;&#34;Whether this component has been &#34;started&#34; yet.

    When this is `builtins.False` executing the cluster will always do nothing.
    &#34;&#34;&#34;

    def __init__(
        self,
        *,
        checks: typing.Optional[typing.Iterable[traits.CheckT]] = None,
        hooks: typing.Optional[traits.Hooks] = None,
    ) -&gt; None:
        self._checks = set(checks) if checks else set()
        self._client: typing.Optional[traits.Client] = None
        self._commands: typing.MutableSet[traits.ExecutableCommand] = set()
        self._hooks = hooks
        self._listeners: typing.MutableSet[
            typing.Tuple[typing.Type[base_events.Event], event_dispatcher.CallbackT[typing.Any]]
        ] = set()
        self._metadata: typing.MutableMapping[typing.Any, typing.Any] = {}
        self.started = False
        self._load_from_properties()

    def __repr__(self) -&gt; str:
        return f&#34;Component &lt;{type(self).__name__}, {len(self._commands)} commands&gt;&#34;

    @property
    def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
        return frozenset(self._checks)

    @property
    def client(self) -&gt; typing.Optional[traits.Client]:
        return self._client

    @property
    def commands(self) -&gt; typing.AbstractSet[traits.ExecutableCommand]:
        return frozenset(self._commands)

    @property
    def hooks(self) -&gt; typing.Optional[traits.Hooks]:
        return self._hooks

    # Seeing as this class isn&#39;t slotted we cannot overwrite settable properties with instance variables.
    @hooks.setter
    def hooks(self, hooks_: traits.Hooks, /) -&gt; None:
        self._hooks = hooks_

    @property
    def listeners(
        self,
    ) -&gt; typing.AbstractSet[typing.Tuple[typing.Type[base_events.Event], event_dispatcher.CallbackT[typing.Any]]]:
        return frozenset(self._listeners)

    @property
    def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
        return self._metadata

    def add_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.add(check)

    def remove_check(self, check: traits.CheckT, /) -&gt; None:
        self._checks.remove(check)

    def with_check(self, check: traits.CheckT, /) -&gt; traits.CheckT:
        self.add_check(check)
        return check

    def add_command(self, command: typing.Union[traits.ExecutableCommand, traits.CommandDescriptor], /) -&gt; None:
        command = command.build_command(self) if isinstance(command, traits.CommandDescriptor) else command
        self._commands.add(command)

    def remove_command(self, command: traits.ExecutableCommand, /) -&gt; None:
        self._commands.remove(command)

    def add_listener(
        self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /
    ) -&gt; None:
        self._listeners.add((event, listener))

        if self.started and self._client:
            self._client.dispatch_service.dispatcher.subscribe(event, listener)

    def remove_listener(
        self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /
    ) -&gt; None:
        self._listeners.remove((event, listener))

        if self.started and self._client:
            self._client.dispatch_service.dispatcher.unsubscribe(event, listener)

    def bind_client(self, client: traits.Client, /) -&gt; None:
        self._client = client
        for event_, listener in self._listeners:
            self._client.dispatch_service.dispatcher.subscribe(event_, listener)

        for command_ in self._commands:
            command_.bind_client(client)

    async def check_context(
        self, ctx: traits.Context, /, *, name_prefix: str = &#34;&#34;
    ) -&gt; typing.AsyncIterator[traits.FoundCommand]:
        if await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks):
            async for value in utilities.async_chain(
                command_.check_context(ctx, name_prefix=name_prefix) for command_ in self._commands
            ):
                yield value

    def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
        yield from itertools.chain.from_iterable(command_.check_name(name) for command_ in self._commands)

    async def close(self) -&gt; None:
        if not self.started:
            return

        self.started = False
        if self._client:
            for event_, listener in self._listeners:
                self._client.dispatch_service.dispatcher.unsubscribe(event_, listener)

    async def open(self) -&gt; None:
        if self.started:
            return

        # This is duplicated between both open and bind_cluster to ensure that these are registered
        # as soon as possible the first time this is binded to a client and that these are
        # re-registered everytime an object is restarted.
        if self._client:
            for event_, listener in self._listeners:
                try:
                    self._client.dispatch_service.dispatcher.unsubscribe(event_, listener)
                except (KeyError, ValueError, LookupError):  # TODO: what does hikari raise?
                    continue

                self._client.dispatch_service.dispatcher.subscribe(event_, listener)

        self.started = True

    async def execute(
        self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
    ) -&gt; bool:
        if not self.started:
            return False

        async for command_ in self.check_context(ctx):
            ctx.triggering_name = command_.name
            ctx.content = ctx.content[len(command_.name) :].lstrip()
            # Only add our hooks and set command if we&#39;re sure we&#39;ll be executing the command here.
            ctx.command = command_.command

            if self.hooks and hooks:
                hooks.add(self.hooks)

            elif self.hooks:
                hooks = {self.hooks}

            await command_.command.execute(ctx, hooks=hooks)
            return True

        return False

    def _load_from_properties(self) -&gt; None:
        for name, member in inspect.getmembers(self):
            if isinstance(member, traits.CommandDescriptor):
                result = member.build_command(self)

                # We don&#39;t want to load in commands which belong to a command group here.
                if not member.is_owned:
                    self.add_command(result)

                setattr(self, name, result.function)

            elif isinstance(member, traits.ListenerDescriptor):
                event_, listener = member.build_listener(self)
                self.add_listener(event_, listener)
                setattr(self, name, listener)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a></li>
<li><a title="tanjun.traits.Executable" href="traits.html#tanjun.traits.Executable">Executable</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tanjun.Component.started"><code class="name">var <span class="ident">started</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this component has been "started" yet.</p>
<p>When this is <code>builtins.False</code> executing the cluster will always do nothing.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.Component.checks"><code class="name">var <span class="ident">checks</span> : AbstractSet[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def checks(self) -&gt; typing.AbstractSet[traits.CheckT]:
    return frozenset(self._checks)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.client"><code class="name">var <span class="ident">client</span> : Union[<a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client(self) -&gt; typing.Optional[traits.Client]:
    return self._client</code></pre>
</details>
</dd>
<dt id="tanjun.Component.commands"><code class="name">var <span class="ident">commands</span> : AbstractSet[<a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self) -&gt; typing.AbstractSet[traits.ExecutableCommand]:
    return frozenset(self._commands)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.hooks"><code class="name">var <span class="ident">hooks</span> : Union[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hooks(self) -&gt; typing.Optional[traits.Hooks]:
    return self._hooks</code></pre>
</details>
</dd>
<dt id="tanjun.Component.listeners"><code class="name">var <span class="ident">listeners</span> : typing.AbstractSet[typing.Tuple[typing.Type[base_events.Event], event_dispatcher.CallbackT[typing.Any]]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def listeners(
    self,
) -&gt; typing.AbstractSet[typing.Tuple[typing.Type[base_events.Event], event_dispatcher.CallbackT[typing.Any]]]:
    return frozenset(self._listeners)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.metadata"><code class="name">var <span class="ident">metadata</span> : MutableMapping[Any, Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; typing.MutableMapping[typing.Any, typing.Any]:
    return self._metadata</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.Component.add_check"><code class="name flex">
<span>def <span class="ident">add_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.add(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.add_command"><code class="name flex">
<span>def <span class="ident">add_command</span></span>(<span>self, command: typing.Union[<a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>, <a title="tanjun.traits.CommandDescriptor" href="traits.html#tanjun.traits.CommandDescriptor">CommandDescriptor</a>], /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_command(self, command: typing.Union[traits.ExecutableCommand, traits.CommandDescriptor], /) -&gt; None:
    command = command.build_command(self) if isinstance(command, traits.CommandDescriptor) else command
    self._commands.add(command)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.add_listener"><code class="name flex">
<span>def <span class="ident">add_listener</span></span>(<span>self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_listener(
    self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /
) -&gt; None:
    self._listeners.add((event, listener))

    if self.started and self._client:
        self._client.dispatch_service.dispatcher.subscribe(event, listener)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.bind_client"><code class="name flex">
<span>def <span class="ident">bind_client</span></span>(<span>self, client: <a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_client(self, client: traits.Client, /) -&gt; None:
    self._client = client
    for event_, listener in self._listeners:
        self._client.dispatch_service.dispatcher.subscribe(event_, listener)

    for command_ in self._commands:
        command_.bind_client(client)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.check_context"><code class="name flex">
<span>async def <span class="ident">check_context</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /, *, name_prefix: str = '') ‑> AsyncIterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_context(
    self, ctx: traits.Context, /, *, name_prefix: str = &#34;&#34;
) -&gt; typing.AsyncIterator[traits.FoundCommand]:
    if await utilities.gather_checks(utilities.await_if_async(check, ctx) for check in self._checks):
        async for value in utilities.async_chain(
            command_.check_context(ctx, name_prefix=name_prefix) for command_ in self._commands
        ):
            yield value</code></pre>
</details>
</dd>
<dt id="tanjun.Component.check_name"><code class="name flex">
<span>def <span class="ident">check_name</span></span>(<span>self, name: str, /) ‑> Iterator[<a title="tanjun.traits.FoundCommand" href="traits.html#tanjun.traits.FoundCommand">FoundCommand</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_name(self, name: str, /) -&gt; typing.Iterator[traits.FoundCommand]:
    yield from itertools.chain.from_iterable(command_.check_name(name) for command_ in self._commands)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    if not self.started:
        return

    self.started = False
    if self._client:
        for event_, listener in self._listeners:
            self._client.dispatch_service.dispatcher.unsubscribe(event_, listener)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.execute"><code class="name flex">
<span>async def <span class="ident">execute</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /, *, hooks: typing.Optional[typing.MutableSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute(
    self, ctx: traits.Context, /, *, hooks: typing.Optional[typing.MutableSet[traits.Hooks]] = None
) -&gt; bool:
    if not self.started:
        return False

    async for command_ in self.check_context(ctx):
        ctx.triggering_name = command_.name
        ctx.content = ctx.content[len(command_.name) :].lstrip()
        # Only add our hooks and set command if we&#39;re sure we&#39;ll be executing the command here.
        ctx.command = command_.command

        if self.hooks and hooks:
            hooks.add(self.hooks)

        elif self.hooks:
            hooks = {self.hooks}

        await command_.command.execute(ctx, hooks=hooks)
        return True

    return False</code></pre>
</details>
</dd>
<dt id="tanjun.Component.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    if self.started:
        return

    # This is duplicated between both open and bind_cluster to ensure that these are registered
    # as soon as possible the first time this is binded to a client and that these are
    # re-registered everytime an object is restarted.
    if self._client:
        for event_, listener in self._listeners:
            try:
                self._client.dispatch_service.dispatcher.unsubscribe(event_, listener)
            except (KeyError, ValueError, LookupError):  # TODO: what does hikari raise?
                continue

            self._client.dispatch_service.dispatcher.subscribe(event_, listener)

    self.started = True</code></pre>
</details>
</dd>
<dt id="tanjun.Component.remove_check"><code class="name flex">
<span>def <span class="ident">remove_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_check(self, check: traits.CheckT, /) -&gt; None:
    self._checks.remove(check)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.remove_command"><code class="name flex">
<span>def <span class="ident">remove_command</span></span>(<span>self, command: <a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_command(self, command: traits.ExecutableCommand, /) -&gt; None:
    self._commands.remove(command)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.remove_listener"><code class="name flex">
<span>def <span class="ident">remove_listener</span></span>(<span>self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_listener(
    self, event: typing.Type[base_events.Event], listener: event_dispatcher.CallbackT[typing.Any], /
) -&gt; None:
    self._listeners.remove((event, listener))

    if self.started and self._client:
        self._client.dispatch_service.dispatcher.unsubscribe(event, listener)</code></pre>
</details>
</dd>
<dt id="tanjun.Component.with_check"><code class="name flex">
<span>def <span class="ident">with_check</span></span>(<span>self, check: <a title="tanjun.traits.CheckT" href="traits.html#tanjun.traits.CheckT">CheckT</a>, /) ‑> Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_check(self, check: traits.CheckT, /) -&gt; traits.CheckT:
    self.add_check(check)
    return check</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.Context"><code class="flex name class">
<span>class <span class="ident">Context</span></span>
<span>(</span><span>client: <a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, /, content: str, message: messages.Message, *, command: typing.Optional[<a title="tanjun.traits.ExecutableCommand" href="traits.html#tanjun.traits.ExecutableCommand">ExecutableCommand</a>] = None, triggering_name: typing.Optional[str] = None, triggering_prefix: typing.Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Standard implementation of a command context as used within Tanjun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Context(traits.Context):
    &#34;&#34;&#34;Standard implementation of a command context as used within Tanjun.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_client&#34;,
        &#34;command&#34;,
        &#34;content&#34;,
        &#34;_message&#34;,
        &#34;_rest&#34;,
        &#34;triggering_name&#34;,
        &#34;triggering_prefix&#34;,
        &#34;_shard&#34;,
    )

    def __init__(
        self,
        client: traits.Client,
        /,
        content: str,
        message: messages.Message,
        *,
        command: typing.Optional[traits.ExecutableCommand] = None,
        triggering_name: typing.Optional[str] = None,
        triggering_prefix: typing.Optional[str] = None,
    ) -&gt; None:
        if message.content is None:
            raise ValueError(&#34;Cannot spawn context with a contentless message.&#34;)

        self._client = client
        self.command = command
        self.content = content
        self._message = message
        self.triggering_name = triggering_name
        self.triggering_prefix = triggering_prefix

    def __repr__(self) -&gt; str:
        return f&#34;Context &lt;{self.message!r}, {self.command!r}&gt;&#34;

    @property
    def cache_service(self) -&gt; typing.Optional[hikari_traits.CacheAware]:
        return self._client.cache_service

    @property
    def client(self) -&gt; traits.Client:
        return self._client

    @property
    def dispatch_service(self) -&gt; hikari_traits.DispatcherAware:
        return self._client.dispatch_service

    @property
    def message(self) -&gt; messages.Message:
        return self._message

    @property
    def rest_service(self) -&gt; hikari_traits.RESTAware:
        return self._client.rest_service

    @property
    def shard_service(self) -&gt; hikari_traits.ShardAware:
        return self._client.shard_service

    @property
    def shard(self) -&gt; shard_.GatewayShard:
        if self.message.guild_id is not None:
            shard_id = snowflakes.calculate_shard_id(self.shard_service, self.message.guild_id)

        else:
            shard_id = 0

        return self.shard_service.shards[shard_id]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.Context.cache_service"><code class="name">var <span class="ident">cache_service</span> : typing.Optional[hikari_traits.CacheAware]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cache_service(self) -&gt; typing.Optional[hikari_traits.CacheAware]:
    return self._client.cache_service</code></pre>
</details>
</dd>
<dt id="tanjun.Context.command"><code class="name">var <span class="ident">command</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Context.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Context.dispatch_service"><code class="name">var <span class="ident">dispatch_service</span> : hikari_traits.DispatcherAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dispatch_service(self) -&gt; hikari_traits.DispatcherAware:
    return self._client.dispatch_service</code></pre>
</details>
</dd>
<dt id="tanjun.Context.message"><code class="name">var <span class="ident">message</span> : messages.Message</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; messages.Message:
    return self._message</code></pre>
</details>
</dd>
<dt id="tanjun.Context.rest_service"><code class="name">var <span class="ident">rest_service</span> : hikari_traits.RESTAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rest_service(self) -&gt; hikari_traits.RESTAware:
    return self._client.rest_service</code></pre>
</details>
</dd>
<dt id="tanjun.Context.shard"><code class="name">var <span class="ident">shard</span> : shard_.GatewayShard</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shard(self) -&gt; shard_.GatewayShard:
    if self.message.guild_id is not None:
        shard_id = snowflakes.calculate_shard_id(self.shard_service, self.message.guild_id)

    else:
        shard_id = 0

    return self.shard_service.shards[shard_id]</code></pre>
</details>
</dd>
<dt id="tanjun.Context.shard_service"><code class="name">var <span class="ident">shard_service</span> : hikari_traits.ShardAware</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shard_service(self) -&gt; hikari_traits.ShardAware:
    return self._client.shard_service</code></pre>
</details>
</dd>
<dt id="tanjun.Context.triggering_name"><code class="name">var <span class="ident">triggering_name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Context.triggering_prefix"><code class="name">var <span class="ident">triggering_prefix</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a></b></code>:
<ul class="hlist">
<li><code><a title="tanjun.traits.Context.client" href="traits.html#tanjun.traits.Context.client">client</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tanjun.ConversionError"><code class="flex name class">
<span>class <span class="ident">ConversionError</span></span>
<span>(</span><span>parameter: <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, errors: typing.Iterable[ValueError], /)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised by a parser parameter when it failed to converter a value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>The parameter this was raised by.</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>typing.Iterable[ValueError]</code></dt>
<dd>An iterable of the source value errors which were raised during conversion/</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConversionError(ParserError):
    &#34;&#34;&#34;Error raised by a parser parameter when it failed to converter a value.

    Parameters
    ----------
    parameter : tanjun.traits.Parameter
        The parameter this was raised by.
    errors : typing.Iterable[ValueError]
        An iterable of the source value errors which were raised during conversion/
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;errors&#34;,)

    errors: typing.Sequence[ValueError]
    &#34;&#34;&#34;Sequence of the errors that were caught during conversion for this parameter.&#34;&#34;&#34;

    parameter: traits.Parameter
    &#34;&#34;&#34;Parameter this error was raised for.&#34;&#34;&#34;

    def __init__(self, parameter: traits.Parameter, errors: typing.Iterable[ValueError], /) -&gt; None:
        option_or_argument = &#34;option&#34; if isinstance(parameter, traits.Option) else &#34;argument&#34;
        super().__init__(f&#34;Couldn&#39;t convert {option_or_argument} &#39;{parameter.key}&#39;&#34;, parameter)
        self.errors = tuple(errors)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></li>
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.ConversionError.errors"><code class="name">var <span class="ident">errors</span> : Sequence[ValueError]</code></dt>
<dd>
<div class="desc"><p>Sequence of the errors that were caught during conversion for this parameter.</p></div>
</dd>
<dt id="tanjun.ConversionError.parameter"><code class="name">var <span class="ident">parameter</span> : <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>
<div class="desc"><p>Parameter this error was raised for.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></b></code>:
<ul class="hlist">
<li><code><a title="tanjun.errors.ParserError.message" href="errors.html#tanjun.errors.ParserError.message">message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tanjun.EmojiConverter"><code class="flex name class">
<span>class <span class="ident">EmojiConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmojiConverter(BaseConverter[emojis.KnownCustomEmoji]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; emojis.KnownCustomEmoji:
        if ctx.client.cache_service:
            emoji_id = EmojiIDParser.match_id(argument, message=&#34;No valid emoji or emoji ID found&#34;)
            if emoji := ctx.client.cache_service.cache.get_emoji(emoji_id):
                return emoji

        raise ValueError(&#34;Couldn&#39;t find emoji&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_EMOJIS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (emojis.CustomEmoji,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.EmojiConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.EmojiConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.emojis.KnownCustomEmoji</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; emojis.KnownCustomEmoji:
    if ctx.client.cache_service:
        emoji_id = EmojiIDParser.match_id(argument, message=&#34;No valid emoji or emoji ID found&#34;)
        if emoji := ctx.client.cache_service.cache.get_emoji(emoji_id):
            return emoji

    raise ValueError(&#34;Couldn&#39;t find emoji&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.EmojiConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_EMOJIS</code></pre>
</details>
</dd>
<dt id="tanjun.EmojiConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.EmojiConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (emojis.CustomEmoji,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.FailedCheck"><code class="flex name class">
<span>class <span class="ident">FailedCheck</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised as an alternative to returning <code>False</code> in a check.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FailedCheck(TanjunError, RuntimeError):
    &#34;&#34;&#34;Error raised as an alternative to returning `False` in a check.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.RuntimeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tanjun.GuildConverter"><code class="flex name class">
<span>class <span class="ident">GuildConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuildConverter(BaseConverter[guilds.GatewayGuild]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.GatewayGuild:
        if ctx.client.cache_service:
            guild_id = SnowflakeParser.match_id(argument, message=&#34;No valid guild ID found&#34;)
            if guild := ctx.client.cache_service.cache.get_guild(guild_id):
                return guild

        raise ValueError(&#34;Couldn&#39;t find guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Guild,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.GuildConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.GuildConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.guilds.GatewayGuild</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.GatewayGuild:
    if ctx.client.cache_service:
        guild_id = SnowflakeParser.match_id(argument, message=&#34;No valid guild ID found&#34;)
        if guild := ctx.client.cache_service.cache.get_guild(guild_id):
            return guild

    raise ValueError(&#34;Couldn&#39;t find guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.GuildConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.GuildConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.GuildConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Guild,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.Hooks"><code class="flex name class">
<span>class <span class="ident">Hooks</span></span>
<span>(</span><span>*, on_error: typing.Optional[<a title="tanjun.traits.ErrorHookT" href="traits.html#tanjun.traits.ErrorHookT">ErrorHookT</a>] = None, parser_error: typing.Optional[<a title="tanjun.traits.ParserHookT" href="traits.html#tanjun.traits.ParserHookT">ParserHookT</a>] = None, pre_execution: typing.Optional[<a title="tanjun.traits.PreExecutionHookT" href="traits.html#tanjun.traits.PreExecutionHookT">PreExecutionHookT</a>] = None, post_execution: typing.Optional[<a title="tanjun.traits.HookT" href="traits.html#tanjun.traits.HookT">HookT</a>] = None, on_success: typing.Optional[<a title="tanjun.traits.HookT" href="traits.html#tanjun.traits.HookT">HookT</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hooks(traits.Hooks):
    __slots__: typing.Sequence[str] = (&#34;_error&#34;, &#34;_parser_error&#34;, &#34;_pre_execution&#34;, &#34;_post_execution&#34;, &#34;_success&#34;)

    def __init__(
        self,
        *,
        on_error: typing.Optional[traits.ErrorHookT] = None,
        parser_error: typing.Optional[traits.ParserHookT] = None,
        pre_execution: typing.Optional[traits.PreExecutionHookT] = None,
        post_execution: typing.Optional[traits.HookT] = None,
        on_success: typing.Optional[traits.HookT] = None,
    ) -&gt; None:
        self._error = on_error
        self._parser_error = parser_error
        self._pre_execution = pre_execution
        self._post_execution = post_execution
        self._success = on_success

    def __repr__(self) -&gt; str:
        return (
            f&#34;Hooks &lt;{self._error!r}, {self._parser_error!r}, {self._pre_execution!r}, &#34;
            f&#34;{self._post_execution!r}, {self._success!r}&gt;&#34;
        )

    def with_on_error(self, hook: typing.Optional[traits.ErrorHookT], /) -&gt; typing.Optional[traits.ErrorHookT]:
        self._error = hook
        return hook

    def with_on_parser_error(self, hook: typing.Optional[traits.ParserHookT], /) -&gt; typing.Optional[traits.ParserHookT]:
        self._parser_error = hook
        return hook

    def with_post_execution(self, hook: typing.Optional[traits.HookT], /) -&gt; typing.Optional[traits.HookT]:
        self._post_execution = hook
        return hook

    def with_pre_execution(
        self, hook: typing.Optional[traits.PreExecutionHookT], /
    ) -&gt; typing.Optional[traits.PreExecutionHookT]:
        self._pre_execution = hook
        return hook

    def with_on_success(self, hook: typing.Optional[traits.HookT], /) -&gt; typing.Optional[traits.HookT]:
        self._success = hook
        return hook

    async def trigger_error(
        self,
        ctx: Context,
        /,
        exception: BaseException,
        *,
        hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
    ) -&gt; None:  # TODO: return True to indicate &#34;raise&#34; else False or None to suppress
        if self._error:
            await utilities.await_if_async(self._error, ctx, exception)

        if hooks:
            await asyncio.gather(*(hook.trigger_error(ctx, exception) for hook in hooks))

    async def trigger_parser_error(
        self,
        ctx: Context,
        /,
        exception: errors.ParserError,
        hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
    ) -&gt; None:
        if self._parser_error:
            await utilities.await_if_async(self._parser_error, ctx, exception)

        if hooks:
            await asyncio.gather(*(hook.trigger_parser_error(ctx, exception) for hook in hooks))

    async def trigger_post_execution(
        self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None
    ) -&gt; None:
        if self._post_execution:
            await utilities.await_if_async(self._post_execution, ctx)

        if hooks:
            await asyncio.gather(*(hook.trigger_post_execution(ctx) for hook in hooks))

    async def trigger_pre_execution(
        self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
    ) -&gt; bool:
        if self._pre_execution and await utilities.await_if_async(self._pre_execution, ctx) is False:
            return False

        if hooks:
            return await utilities.gather_checks(hook.trigger_pre_execution(ctx) for hook in hooks)

        return True

    async def trigger_success(
        self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None
    ) -&gt; None:
        if self._success:
            await utilities.await_if_async(self._success, ctx)

        if hooks:
            await asyncio.gather(*(hook.trigger_success(ctx) for hook in hooks))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tanjun.Hooks.trigger_error"><code class="name flex">
<span>async def <span class="ident">trigger_error</span></span>(<span>self, ctx: <a title="tanjun.Context" href="#tanjun.Context">Context</a>, /, exception: BaseException, *, hooks: typing.Optional[typing.AbstractSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trigger_error(
    self,
    ctx: Context,
    /,
    exception: BaseException,
    *,
    hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
) -&gt; None:  # TODO: return True to indicate &#34;raise&#34; else False or None to suppress
    if self._error:
        await utilities.await_if_async(self._error, ctx, exception)

    if hooks:
        await asyncio.gather(*(hook.trigger_error(ctx, exception) for hook in hooks))</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.trigger_parser_error"><code class="name flex">
<span>async def <span class="ident">trigger_parser_error</span></span>(<span>self, ctx: <a title="tanjun.Context" href="#tanjun.Context">Context</a>, /, exception: <a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a>, hooks: typing.Optional[typing.AbstractSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trigger_parser_error(
    self,
    ctx: Context,
    /,
    exception: errors.ParserError,
    hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
) -&gt; None:
    if self._parser_error:
        await utilities.await_if_async(self._parser_error, ctx, exception)

    if hooks:
        await asyncio.gather(*(hook.trigger_parser_error(ctx, exception) for hook in hooks))</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.trigger_post_execution"><code class="name flex">
<span>async def <span class="ident">trigger_post_execution</span></span>(<span>self, ctx: <a title="tanjun.Context" href="#tanjun.Context">Context</a>, /, *, hooks: typing.Optional[typing.AbstractSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trigger_post_execution(
    self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None
) -&gt; None:
    if self._post_execution:
        await utilities.await_if_async(self._post_execution, ctx)

    if hooks:
        await asyncio.gather(*(hook.trigger_post_execution(ctx) for hook in hooks))</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.trigger_pre_execution"><code class="name flex">
<span>async def <span class="ident">trigger_pre_execution</span></span>(<span>self, ctx: <a title="tanjun.Context" href="#tanjun.Context">Context</a>, /, *, hooks: typing.Optional[typing.AbstractSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trigger_pre_execution(
    self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None,
) -&gt; bool:
    if self._pre_execution and await utilities.await_if_async(self._pre_execution, ctx) is False:
        return False

    if hooks:
        return await utilities.gather_checks(hook.trigger_pre_execution(ctx) for hook in hooks)

    return True</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.trigger_success"><code class="name flex">
<span>async def <span class="ident">trigger_success</span></span>(<span>self, ctx: <a title="tanjun.Context" href="#tanjun.Context">Context</a>, /, *, hooks: typing.Optional[typing.AbstractSet[<a title="tanjun.traits.Hooks" href="traits.html#tanjun.traits.Hooks">Hooks</a>]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trigger_success(
    self, ctx: Context, /, *, hooks: typing.Optional[typing.AbstractSet[traits.Hooks]] = None
) -&gt; None:
    if self._success:
        await utilities.await_if_async(self._success, ctx)

    if hooks:
        await asyncio.gather(*(hook.trigger_success(ctx) for hook in hooks))</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.with_on_error"><code class="name flex">
<span>def <span class="ident">with_on_error</span></span>(<span>self, hook: typing.Optional[<a title="tanjun.traits.ErrorHookT" href="traits.html#tanjun.traits.ErrorHookT">ErrorHookT</a>], /) ‑> Union[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>, BaseException], Union[Coroutine[Any, Any, NoneType], NoneType]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_on_error(self, hook: typing.Optional[traits.ErrorHookT], /) -&gt; typing.Optional[traits.ErrorHookT]:
    self._error = hook
    return hook</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.with_on_parser_error"><code class="name flex">
<span>def <span class="ident">with_on_parser_error</span></span>(<span>self, hook: typing.Optional[<a title="tanjun.traits.ParserHookT" href="traits.html#tanjun.traits.ParserHookT">ParserHookT</a>], /) ‑> Union[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>, <a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a>], Union[Coroutine[Any, Any, NoneType], NoneType]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_on_parser_error(self, hook: typing.Optional[traits.ParserHookT], /) -&gt; typing.Optional[traits.ParserHookT]:
    self._parser_error = hook
    return hook</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.with_on_success"><code class="name flex">
<span>def <span class="ident">with_on_success</span></span>(<span>self, hook: typing.Optional[<a title="tanjun.traits.HookT" href="traits.html#tanjun.traits.HookT">HookT</a>], /) ‑> Union[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, NoneType], NoneType]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_on_success(self, hook: typing.Optional[traits.HookT], /) -&gt; typing.Optional[traits.HookT]:
    self._success = hook
    return hook</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.with_post_execution"><code class="name flex">
<span>def <span class="ident">with_post_execution</span></span>(<span>self, hook: typing.Optional[<a title="tanjun.traits.HookT" href="traits.html#tanjun.traits.HookT">HookT</a>], /) ‑> Union[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, NoneType], NoneType]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_post_execution(self, hook: typing.Optional[traits.HookT], /) -&gt; typing.Optional[traits.HookT]:
    self._post_execution = hook
    return hook</code></pre>
</details>
</dd>
<dt id="tanjun.Hooks.with_pre_execution"><code class="name flex">
<span>def <span class="ident">with_pre_execution</span></span>(<span>self, hook: typing.Optional[<a title="tanjun.traits.PreExecutionHookT" href="traits.html#tanjun.traits.PreExecutionHookT">PreExecutionHookT</a>], /) ‑> Union[Callable[[<a title="tanjun.Context" href="#tanjun.Context">Context</a>], Union[Coroutine[Any, Any, bool], bool]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_pre_execution(
    self, hook: typing.Optional[traits.PreExecutionHookT], /
) -&gt; typing.Optional[traits.PreExecutionHookT]:
    self._pre_execution = hook
    return hook</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.InviteConverter"><code class="flex name class">
<span>class <span class="ident">InviteConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InviteConverter(BaseConverter[invites.InviteWithMetadata]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; invites.InviteWithMetadata:
        if ctx.client.cache_service:
            if invite := ctx.client.cache_service.cache.get_invite(argument):
                return invite

        raise ValueError(&#34;Couldn&#39;t find invite&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_INVITES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (invites.Invite,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.InviteConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.InviteConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.invites.InviteWithMetadata</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; invites.InviteWithMetadata:
    if ctx.client.cache_service:
        if invite := ctx.client.cache_service.cache.get_invite(argument):
            return invite

    raise ValueError(&#34;Couldn&#39;t find invite&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.InviteConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_INVITES</code></pre>
</details>
</dd>
<dt id="tanjun.InviteConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.InviteConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (invites.Invite,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.MemberConverter"><code class="flex name class">
<span>class <span class="ident">MemberConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemberConverter(BaseConverter[guilds.Member]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Member:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a member from a DM channel&#34;)

        if ctx.client.cache_service:
            member_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID found&#34;)
            if member := ctx.client.cache_service.cache.get_member(ctx.message.guild_id, member_id):
                return member

        raise ValueError(&#34;Couldn&#39;t find member in this guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Member,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.MemberConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.MemberConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.guilds.Member</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Member:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a member from a DM channel&#34;)

    if ctx.client.cache_service:
        member_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID found&#34;)
        if member := ctx.client.cache_service.cache.get_member(ctx.message.guild_id, member_id):
            return member

    raise ValueError(&#34;Couldn&#39;t find member in this guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.MemberConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_MEMBERS</code></pre>
</details>
</dd>
<dt id="tanjun.MemberConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.MemberConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Member,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.NotEnoughArgumentsError"><code class="flex name class">
<span>class <span class="ident">NotEnoughArgumentsError</span></span>
<span>(</span><span>message: str, parameter: <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised by the parser when not enough arguments are found for a parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>The parameter this error was raised for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotEnoughArgumentsError(ParserError):
    &#34;&#34;&#34;Error raised by the parser when not enough arguments are found for a parameter.

    Parameters
    ----------
    parameter : tanjun.traits.Parameter
        The parameter this error was raised for
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    parameter: traits.Parameter
    &#34;&#34;&#34;Parameter this error was raised for.&#34;&#34;&#34;

    def __init__(self, message: str, parameter: traits.Parameter, /) -&gt; None:
        super().__init__(message, parameter)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></li>
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.NotEnoughArgumentsError.parameter"><code class="name">var <span class="ident">parameter</span> : <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>
<div class="desc"><p>Parameter this error was raised for.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></b></code>:
<ul class="hlist">
<li><code><a title="tanjun.errors.ParserError.message" href="errors.html#tanjun.errors.ParserError.message">message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tanjun.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>key: str, name: str, *names: str, converters: typing.Optional[typing.Iterable[<a title="tanjun.traits.ConverterT" href="traits.html#tanjun.traits.ConverterT">ConverterT</a>]] = None, default: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;, flags: typing.Optional[typing.Mapping[str, typing.Any]] = None, empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = &lt;tanjun.traits.UndefinedDefault object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Option(_Parameter, traits.Option):
    __slots__: typing.Sequence[str] = (&#34;empty_value&#34;, &#34;names&#34;)

    def __init__(
        self,
        key: str,
        name: str,
        *names: str,
        converters: typing.Optional[typing.Iterable[traits.ConverterT]] = None,
        default: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
        flags: typing.Optional[typing.Mapping[str, typing.Any]] = None,
        empty_value: typing.Union[typing.Any, traits.UndefinedDefault] = traits.UNDEFINED_DEFAULT,
    ) -&gt; None:
        names = [name, *names]

        if not all(n.startswith(&#34;-&#34;) for n in names):
            raise ValueError(&#34;All option names must start with `-`&#34;)

        if flags and GREEDY in flags:
            raise ValueError(&#34;Option cannot be greedy&#34;)

        self.empty_value = empty_value
        self.names = names
        super().__init__(key, converters=converters, default=default, flags=flags)

    def __copy__(self) -&gt; Option:
        # TODO: this will error if there&#39;s no set names.
        return Option(
            self.key,
            *self.names,
            converters=list(self._converters) if self._converters else None,
            default=self.default,
            flags=dict(self._flags),
            empty_value=self.empty_value,
        )

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__} &lt;{self.key}, {self.names}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.parsing._Parameter</li>
<li><a title="tanjun.traits.Option" href="traits.html#tanjun.traits.Option">Option</a></li>
<li><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.Option.empty_value"><code class="name">var <span class="ident">empty_value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tanjun.Option.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="tanjun.ParserError"><code class="flex name class">
<span>class <span class="ident">ParserError</span></span>
<span>(</span><span>message: str, parameter: typing.Optional[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>], /)</span>
</code></dt>
<dd>
<div class="desc"><p>Base error raised by a parser or parameter during parsing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other error raised by the parser should subclass this error.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>String message for this error.</dd>
<dt><strong><code>parameter</code></strong> :&ensp;<code>typing.Optional[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>]</code></dt>
<dd>The parameter which caused this error, should be <code>builtins.None</code> if not
applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParserError(TanjunError, ValueError):
    &#34;&#34;&#34;Base error raised by a parser or parameter during parsing.

    !!! note
        Other error raised by the parser should subclass this error.

    Parameters
    ----------
    message : str
        String message for this error.
    parameter : typing.Optional[traits.Parameter]
        The parameter which caused this error, should be `builtins.None` if not
        applicable.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;message&#34;, &#34;parameter&#34;)

    message: str
    &#34;&#34;&#34;String message for this error.

    !!! note
        This may be used as a command response message.
    &#34;&#34;&#34;

    parameter: typing.Optional[traits.Parameter]
    &#34;&#34;&#34;Parameter this was raised for.

    !!! note
        This will be `builtin.None` if it was raised while parsing the provided
        message content.
    &#34;&#34;&#34;

    def __init__(self, message: str, parameter: typing.Optional[traits.Parameter], /) -&gt; None:
        self.message = message
        self.parameter = parameter

    def __str__(self) -&gt; str:
        return self.message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tanjun.errors.ConversionError" href="errors.html#tanjun.errors.ConversionError">ConversionError</a></li>
<li><a title="tanjun.errors.NotEnoughArgumentsError" href="errors.html#tanjun.errors.NotEnoughArgumentsError">NotEnoughArgumentsError</a></li>
<li><a title="tanjun.errors.TooManyArgumentsError" href="errors.html#tanjun.errors.TooManyArgumentsError">TooManyArgumentsError</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.ParserError.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>String message for this error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This may be used as a command response message.</p>
</div></div>
</dd>
<dt id="tanjun.ParserError.parameter"><code class="name">var <span class="ident">parameter</span> : Union[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Parameter this was raised for.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will be <code>builtin.None</code> if it was raised while parsing the provided
message content.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="tanjun.PresenceConverter"><code class="flex name class">
<span>class <span class="ident">PresenceConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresenceConverter(BaseConverter[presences.MemberPresence]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; presences.MemberPresence:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a presence from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid member mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_presence(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find presence in current guild&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.PresenceConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.PresenceConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.presences.MemberPresence</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; presences.MemberPresence:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a presence from a DM channel&#34;)

    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid member mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_presence(ctx.message.guild_id, user_id):
            return user

    raise ValueError(&#34;Couldn&#39;t find presence in current guild&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.RoleConverter"><code class="flex name class">
<span>class <span class="ident">RoleConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoleConverter(BaseConverter[guilds.Role]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Role:
        if ctx.client.cache_service:
            role_id = SnowflakeParser.match_id(argument, message=&#34;No valid role mention or ID  found&#34;)
            if role := ctx.client.cache_service.cache.get_role(role_id):
                return role

        raise ValueError(&#34;Couldn&#39;t find role&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Role,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.RoleConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.RoleConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.guilds.Role</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Role:
    if ctx.client.cache_service:
        role_id = SnowflakeParser.match_id(argument, message=&#34;No valid role mention or ID  found&#34;)
        if role := ctx.client.cache_service.cache.get_role(role_id):
            return role

    raise ValueError(&#34;Couldn&#39;t find role&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.RoleConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.RoleConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.RoleConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Role,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.ShlexParser"><code class="flex name class">
<span>class <span class="ident">ShlexParser</span></span>
<span>(</span><span>*, parameters: typing.Optional[typing.Iterable[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A shlex based <code><a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a></code> implementation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShlexParser(traits.Parser):
    &#34;&#34;&#34;A shlex based `tanjun.traits.Parser` implementation.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_arguments&#34;, &#34;_options&#34;)

    def __init__(self, *, parameters: typing.Optional[typing.Iterable[traits.Parameter]] = None) -&gt; None:
        self._arguments: typing.MutableSequence[traits.Argument] = []
        self._options: typing.MutableSequence[traits.Option] = []

        if parameters is not None:
            self.set_parameters(parameters)

    @property
    def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        return (*self._arguments, *self._options)

    def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.append(parameter)

        else:
            self._arguments.append(parameter)
            found_final_argument = False

            for argument_ in self._arguments:
                if found_final_argument:
                    del self._arguments[-1]
                    raise ValueError(&#34;Multi or greedy argument must be the last argument&#34;)

                found_final_argument = MULTI in argument_.flags or GREEDY in argument_.flags

    def remove_parameter(self, parameter: traits.Parameter, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        if isinstance(parameter, traits.Option):
            self._options.remove(parameter)

        else:
            self._arguments.remove(parameter)

    def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        self._arguments = []
        self._options = []

        for parameter_ in parameters:
            self.add_parameter(parameter_)

    def bind_client(self, client: traits.Client, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_client(client)

    def bind_component(self, component: traits.Component, /) -&gt; None:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        for parameter in itertools.chain(self._options, self._arguments):
            parameter.bind_component(component)

    async def parse(
        self, ctx: traits.Context, /
    ) -&gt; typing.Tuple[typing.Sequence[typing.Any], typing.Mapping[str, typing.Any]]:
        # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
        parser = SemanticShlex(ctx)
        arguments = await parser.get_arguments(self._arguments)
        options = await parser.get_options(self._options)
        return arguments, options</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.traits.Parser" href="traits.html#tanjun.traits.Parser">Parser</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.ShlexParser.parameters"><code class="name">var <span class="ident">parameters</span> : Sequence[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; typing.Sequence[traits.Parameter]:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    return (*self._arguments, *self._options)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tanjun.ShlexParser.add_parameter"><code class="name flex">
<span>def <span class="ident">add_parameter</span></span>(<span>self, parameter: <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parameter(self, parameter: traits.Parameter, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    if isinstance(parameter, traits.Option):
        self._options.append(parameter)

    else:
        self._arguments.append(parameter)
        found_final_argument = False

        for argument_ in self._arguments:
            if found_final_argument:
                del self._arguments[-1]
                raise ValueError(&#34;Multi or greedy argument must be the last argument&#34;)

            found_final_argument = MULTI in argument_.flags or GREEDY in argument_.flags</code></pre>
</details>
</dd>
<dt id="tanjun.ShlexParser.bind_client"><code class="name flex">
<span>def <span class="ident">bind_client</span></span>(<span>self, client: <a title="tanjun.traits.Client" href="traits.html#tanjun.traits.Client">Client</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_client(self, client: traits.Client, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    for parameter in itertools.chain(self._options, self._arguments):
        parameter.bind_client(client)</code></pre>
</details>
</dd>
<dt id="tanjun.ShlexParser.bind_component"><code class="name flex">
<span>def <span class="ident">bind_component</span></span>(<span>self, component: <a title="tanjun.traits.Component" href="traits.html#tanjun.traits.Component">Component</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_component(self, component: traits.Component, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    for parameter in itertools.chain(self._options, self._arguments):
        parameter.bind_component(component)</code></pre>
</details>
</dd>
<dt id="tanjun.ShlexParser.parse"><code class="name flex">
<span>async def <span class="ident">parse</span></span>(<span>self, ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, /) ‑> Tuple[Sequence[Any], Mapping[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def parse(
    self, ctx: traits.Context, /
) -&gt; typing.Tuple[typing.Sequence[typing.Any], typing.Mapping[str, typing.Any]]:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    parser = SemanticShlex(ctx)
    arguments = await parser.get_arguments(self._arguments)
    options = await parser.get_options(self._options)
    return arguments, options</code></pre>
</details>
</dd>
<dt id="tanjun.ShlexParser.remove_parameter"><code class="name flex">
<span>def <span class="ident">remove_parameter</span></span>(<span>self, parameter: <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_parameter(self, parameter: traits.Parameter, /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    if isinstance(parameter, traits.Option):
        self._options.remove(parameter)

    else:
        self._arguments.remove(parameter)</code></pre>
</details>
</dd>
<dt id="tanjun.ShlexParser.set_parameters"><code class="name flex">
<span>def <span class="ident">set_parameters</span></span>(<span>self, parameters: typing.Iterable[<a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>], /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameters(self, parameters: typing.Iterable[traits.Parameter], /) -&gt; None:
    # &lt;&lt;inherited docstring from tanjun.traits.ShlexParser&gt;&gt;.
    self._arguments = []
    self._options = []

    for parameter_ in parameters:
        self.add_parameter(parameter_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.SnowflakeConverter"><code class="flex name class">
<span>class <span class="ident">SnowflakeConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnowflakeConverter(BaseConverter[snowflakes.Snowflake]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; snowflakes.Snowflake:
        return SnowflakeParser.match_id(argument, message=&#34;No valid ID found&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (snowflakes.Snowflake,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.SnowflakeConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.SnowflakeConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>_: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.snowflakes.Snowflake</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, _: traits.Context, argument: str, /) -&gt; snowflakes.Snowflake:
    return SnowflakeParser.match_id(argument, message=&#34;No valid ID found&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.SnowflakeConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.NONE</code></pre>
</details>
</dd>
<dt id="tanjun.SnowflakeConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.SnowflakeConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (snowflakes.Snowflake,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.StateWarning"><code class="flex name class">
<span>class <span class="ident">StateWarning</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Warning raised when a utility is loaded without access to state stores it depends on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateWarning(RuntimeWarning):
    &#34;&#34;&#34;Warning raised when a utility is loaded without access to state stores it depends on.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.RuntimeWarning</li>
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tanjun.TanjunError"><code class="flex name class">
<span>class <span class="ident">TanjunError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all errors raised by Tanjun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TanjunError(Exception):
    &#34;&#34;&#34;The base class for all errors raised by Tanjun.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tanjun.errors.CommandError" href="errors.html#tanjun.errors.CommandError">CommandError</a></li>
<li><a title="tanjun.errors.FailedCheck" href="errors.html#tanjun.errors.FailedCheck">FailedCheck</a></li>
<li><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></li>
</ul>
</dd>
<dt id="tanjun.TanjunWarning"><code class="flex name class">
<span>class <span class="ident">TanjunWarning</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all warnings raised by Tanjun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TanjunWarning(RuntimeWarning):
    &#34;&#34;&#34;The base class for all warnings raised by Tanjun.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.RuntimeWarning</li>
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tanjun.TooManyArgumentsError"><code class="flex name class">
<span>class <span class="ident">TooManyArgumentsError</span></span>
<span>(</span><span>message: str, parameter: <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a>, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised by the parser when too many arguments are found for a parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code><a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>The parameter this error was raised for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TooManyArgumentsError(ParserError):
    &#34;&#34;&#34;Error raised by the parser when too many arguments are found for a parameter.

    Parameters
    ----------
    parameter : tanjun.traits.Parameter
        The parameter this error was raised for
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    parameter: traits.Parameter
    &#34;&#34;&#34;Parameter this error was raised for.&#34;&#34;&#34;

    def __init__(self, message: str, parameter: traits.Parameter, /) -&gt; None:
        super().__init__(message, parameter)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></li>
<li><a title="tanjun.errors.TanjunError" href="errors.html#tanjun.errors.TanjunError">TanjunError</a></li>
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tanjun.TooManyArgumentsError.parameter"><code class="name">var <span class="ident">parameter</span> : <a title="tanjun.traits.Parameter" href="traits.html#tanjun.traits.Parameter">Parameter</a></code></dt>
<dd>
<div class="desc"><p>Parameter this error was raised for.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tanjun.errors.ParserError" href="errors.html#tanjun.errors.ParserError">ParserError</a></b></code>:
<ul class="hlist">
<li><code><a title="tanjun.errors.ParserError.message" href="errors.html#tanjun.errors.ParserError.message">message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tanjun.UserConverter"><code class="flex name class">
<span>class <span class="ident">UserConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserConverter(BaseConverter[users.User]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; users.User:
        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_user(user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find user&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (users.User,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.UserConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.UserConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.users.User</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; users.User:
    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_user(user_id):
            return user

    raise ValueError(&#34;Couldn&#39;t find user&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.UserConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_MEMBERS</code></pre>
</details>
</dd>
<dt id="tanjun.UserConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.UserConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (users.User,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.VoiceStateConverter"><code class="flex name class">
<span>class <span class="ident">VoiceStateConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoiceStateConverter(BaseConverter[voices.VoiceState]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; voices.VoiceState:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a voice state from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_voice_state(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Voice state couldn&#39;t be found for current guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_VOICE_STATES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (voices.VoiceState,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.VoiceStateConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.VoiceStateConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: <a title="tanjun.traits.Context" href="traits.html#tanjun.traits.Context">Context</a>, argument: str, /) ‑> hikari.voices.VoiceState</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; voices.VoiceState:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a voice state from a DM channel&#34;)

    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_voice_state(ctx.message.guild_id, user_id):
            return user

    raise ValueError(&#34;Voice state couldn&#39;t be found for current guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.VoiceStateConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_VOICE_STATES</code></pre>
</details>
</dd>
<dt id="tanjun.VoiceStateConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.VoiceStateConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (voices.VoiceState,)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="tanjun.about" href="about.html">tanjun.about</a></code></li>
<li><code><a title="tanjun.checks" href="checks.html">tanjun.checks</a></code></li>
<li><code><a title="tanjun.clients" href="clients.html">tanjun.clients</a></code></li>
<li><code><a title="tanjun.commands" href="commands.html">tanjun.commands</a></code></li>
<li><code><a title="tanjun.components" href="components.html">tanjun.components</a></code></li>
<li><code><a title="tanjun.context" href="context.html">tanjun.context</a></code></li>
<li><code><a title="tanjun.conversion" href="conversion.html">tanjun.conversion</a></code></li>
<li><code><a title="tanjun.errors" href="errors.html">tanjun.errors</a></code></li>
<li><code><a title="tanjun.hooks" href="hooks.html">tanjun.hooks</a></code></li>
<li><code><a title="tanjun.parsing" href="parsing.html">tanjun.parsing</a></code></li>
<li><code><a title="tanjun.traits" href="traits.html">tanjun.traits</a></code></li>
<li><code><a title="tanjun.utilities" href="utilities.html">tanjun.utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tanjun.as_command" href="#tanjun.as_command">as_command</a></code></li>
<li><code><a title="tanjun.as_event" href="#tanjun.as_event">as_event</a></code></li>
<li><code><a title="tanjun.as_group" href="#tanjun.as_group">as_group</a></code></li>
<li><code><a title="tanjun.as_loader" href="#tanjun.as_loader">as_loader</a></code></li>
<li><code><a title="tanjun.parser_descriptor" href="#tanjun.parser_descriptor">parser_descriptor</a></code></li>
<li><code><a title="tanjun.verify_parameters" href="#tanjun.verify_parameters">verify_parameters</a></code></li>
<li><code><a title="tanjun.with_argument" href="#tanjun.with_argument">with_argument</a></code></li>
<li><code><a title="tanjun.with_author_permission_check" href="#tanjun.with_author_permission_check">with_author_permission_check</a></code></li>
<li><code><a title="tanjun.with_bot_permission_check" href="#tanjun.with_bot_permission_check">with_bot_permission_check</a></code></li>
<li><code><a title="tanjun.with_dm_check" href="#tanjun.with_dm_check">with_dm_check</a></code></li>
<li><code><a title="tanjun.with_greedy_argument" href="#tanjun.with_greedy_argument">with_greedy_argument</a></code></li>
<li><code><a title="tanjun.with_guild_check" href="#tanjun.with_guild_check">with_guild_check</a></code></li>
<li><code><a title="tanjun.with_multi_argument" href="#tanjun.with_multi_argument">with_multi_argument</a></code></li>
<li><code><a title="tanjun.with_multi_option" href="#tanjun.with_multi_option">with_multi_option</a></code></li>
<li><code><a title="tanjun.with_nsfw_check" href="#tanjun.with_nsfw_check">with_nsfw_check</a></code></li>
<li><code><a title="tanjun.with_option" href="#tanjun.with_option">with_option</a></code></li>
<li><code><a title="tanjun.with_owner_check" href="#tanjun.with_owner_check">with_owner_check</a></code></li>
<li><code><a title="tanjun.with_parser" href="#tanjun.with_parser">with_parser</a></code></li>
<li><code><a title="tanjun.with_sfw_check" href="#tanjun.with_sfw_check">with_sfw_check</a></code></li>
<li><code><a title="tanjun.with_typed_parameters" href="#tanjun.with_typed_parameters">with_typed_parameters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tanjun.Argument" href="#tanjun.Argument">Argument</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.ChannelConverter" href="#tanjun.ChannelConverter">ChannelConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.ChannelConverter.cache_bound" href="#tanjun.ChannelConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.ChannelConverter.convert" href="#tanjun.ChannelConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.ChannelConverter.intents" href="#tanjun.ChannelConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.ChannelConverter.is_inheritable" href="#tanjun.ChannelConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.ChannelConverter.types" href="#tanjun.ChannelConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Client" href="#tanjun.Client">Client</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.Client.add_check" href="#tanjun.Client.add_check">add_check</a></code></li>
<li><code><a title="tanjun.Client.add_component" href="#tanjun.Client.add_component">add_component</a></code></li>
<li><code><a title="tanjun.Client.add_prefix" href="#tanjun.Client.add_prefix">add_prefix</a></code></li>
<li><code><a title="tanjun.Client.cache_service" href="#tanjun.Client.cache_service">cache_service</a></code></li>
<li><code><a title="tanjun.Client.check" href="#tanjun.Client.check">check</a></code></li>
<li><code><a title="tanjun.Client.check_context" href="#tanjun.Client.check_context">check_context</a></code></li>
<li><code><a title="tanjun.Client.check_human" href="#tanjun.Client.check_human">check_human</a></code></li>
<li><code><a title="tanjun.Client.check_name" href="#tanjun.Client.check_name">check_name</a></code></li>
<li><code><a title="tanjun.Client.check_prefix" href="#tanjun.Client.check_prefix">check_prefix</a></code></li>
<li><code><a title="tanjun.Client.checks" href="#tanjun.Client.checks">checks</a></code></li>
<li><code><a title="tanjun.Client.close" href="#tanjun.Client.close">close</a></code></li>
<li><code><a title="tanjun.Client.components" href="#tanjun.Client.components">components</a></code></li>
<li><code><a title="tanjun.Client.dispatch_service" href="#tanjun.Client.dispatch_service">dispatch_service</a></code></li>
<li><code><a title="tanjun.Client.hooks" href="#tanjun.Client.hooks">hooks</a></code></li>
<li><code><a title="tanjun.Client.load_from_modules" href="#tanjun.Client.load_from_modules">load_from_modules</a></code></li>
<li><code><a title="tanjun.Client.metadata" href="#tanjun.Client.metadata">metadata</a></code></li>
<li><code><a title="tanjun.Client.on_message_create" href="#tanjun.Client.on_message_create">on_message_create</a></code></li>
<li><code><a title="tanjun.Client.open" href="#tanjun.Client.open">open</a></code></li>
<li><code><a title="tanjun.Client.prefixes" href="#tanjun.Client.prefixes">prefixes</a></code></li>
<li><code><a title="tanjun.Client.remove_check" href="#tanjun.Client.remove_check">remove_check</a></code></li>
<li><code><a title="tanjun.Client.remove_component" href="#tanjun.Client.remove_component">remove_component</a></code></li>
<li><code><a title="tanjun.Client.remove_prefix" href="#tanjun.Client.remove_prefix">remove_prefix</a></code></li>
<li><code><a title="tanjun.Client.rest_service" href="#tanjun.Client.rest_service">rest_service</a></code></li>
<li><code><a title="tanjun.Client.shard_service" href="#tanjun.Client.shard_service">shard_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.ColorConverter" href="#tanjun.ColorConverter">ColorConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.ColorConverter.cache_bound" href="#tanjun.ColorConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.ColorConverter.convert" href="#tanjun.ColorConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.ColorConverter.intents" href="#tanjun.ColorConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.ColorConverter.is_inheritable" href="#tanjun.ColorConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.ColorConverter.types" href="#tanjun.ColorConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Command" href="#tanjun.Command">Command</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.Command.add_check" href="#tanjun.Command.add_check">add_check</a></code></li>
<li><code><a title="tanjun.Command.add_name" href="#tanjun.Command.add_name">add_name</a></code></li>
<li><code><a title="tanjun.Command.bind_client" href="#tanjun.Command.bind_client">bind_client</a></code></li>
<li><code><a title="tanjun.Command.bind_component" href="#tanjun.Command.bind_component">bind_component</a></code></li>
<li><code><a title="tanjun.Command.check_context" href="#tanjun.Command.check_context">check_context</a></code></li>
<li><code><a title="tanjun.Command.check_name" href="#tanjun.Command.check_name">check_name</a></code></li>
<li><code><a title="tanjun.Command.checks" href="#tanjun.Command.checks">checks</a></code></li>
<li><code><a title="tanjun.Command.component" href="#tanjun.Command.component">component</a></code></li>
<li><code><a title="tanjun.Command.execute" href="#tanjun.Command.execute">execute</a></code></li>
<li><code><a title="tanjun.Command.function" href="#tanjun.Command.function">function</a></code></li>
<li><code><a title="tanjun.Command.hooks" href="#tanjun.Command.hooks">hooks</a></code></li>
<li><code><a title="tanjun.Command.metadata" href="#tanjun.Command.metadata">metadata</a></code></li>
<li><code><a title="tanjun.Command.names" href="#tanjun.Command.names">names</a></code></li>
<li><code><a title="tanjun.Command.parent" href="#tanjun.Command.parent">parent</a></code></li>
<li><code><a title="tanjun.Command.parser" href="#tanjun.Command.parser">parser</a></code></li>
<li><code><a title="tanjun.Command.remove_check" href="#tanjun.Command.remove_check">remove_check</a></code></li>
<li><code><a title="tanjun.Command.remove_name" href="#tanjun.Command.remove_name">remove_name</a></code></li>
<li><code><a title="tanjun.Command.with_check" href="#tanjun.Command.with_check">with_check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.CommandError" href="#tanjun.CommandError">CommandError</a></code></h4>
<ul class="">
<li><code><a title="tanjun.CommandError.message" href="#tanjun.CommandError.message">message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.CommandGroup" href="#tanjun.CommandGroup">CommandGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.CommandGroup.add_command" href="#tanjun.CommandGroup.add_command">add_command</a></code></li>
<li><code><a title="tanjun.CommandGroup.bind_client" href="#tanjun.CommandGroup.bind_client">bind_client</a></code></li>
<li><code><a title="tanjun.CommandGroup.commands" href="#tanjun.CommandGroup.commands">commands</a></code></li>
<li><code><a title="tanjun.CommandGroup.execute" href="#tanjun.CommandGroup.execute">execute</a></code></li>
<li><code><a title="tanjun.CommandGroup.remove_command" href="#tanjun.CommandGroup.remove_command">remove_command</a></code></li>
<li><code><a title="tanjun.CommandGroup.with_command" href="#tanjun.CommandGroup.with_command">with_command</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Component" href="#tanjun.Component">Component</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.Component.add_check" href="#tanjun.Component.add_check">add_check</a></code></li>
<li><code><a title="tanjun.Component.add_command" href="#tanjun.Component.add_command">add_command</a></code></li>
<li><code><a title="tanjun.Component.add_listener" href="#tanjun.Component.add_listener">add_listener</a></code></li>
<li><code><a title="tanjun.Component.bind_client" href="#tanjun.Component.bind_client">bind_client</a></code></li>
<li><code><a title="tanjun.Component.check_context" href="#tanjun.Component.check_context">check_context</a></code></li>
<li><code><a title="tanjun.Component.check_name" href="#tanjun.Component.check_name">check_name</a></code></li>
<li><code><a title="tanjun.Component.checks" href="#tanjun.Component.checks">checks</a></code></li>
<li><code><a title="tanjun.Component.client" href="#tanjun.Component.client">client</a></code></li>
<li><code><a title="tanjun.Component.close" href="#tanjun.Component.close">close</a></code></li>
<li><code><a title="tanjun.Component.commands" href="#tanjun.Component.commands">commands</a></code></li>
<li><code><a title="tanjun.Component.execute" href="#tanjun.Component.execute">execute</a></code></li>
<li><code><a title="tanjun.Component.hooks" href="#tanjun.Component.hooks">hooks</a></code></li>
<li><code><a title="tanjun.Component.listeners" href="#tanjun.Component.listeners">listeners</a></code></li>
<li><code><a title="tanjun.Component.metadata" href="#tanjun.Component.metadata">metadata</a></code></li>
<li><code><a title="tanjun.Component.open" href="#tanjun.Component.open">open</a></code></li>
<li><code><a title="tanjun.Component.remove_check" href="#tanjun.Component.remove_check">remove_check</a></code></li>
<li><code><a title="tanjun.Component.remove_command" href="#tanjun.Component.remove_command">remove_command</a></code></li>
<li><code><a title="tanjun.Component.remove_listener" href="#tanjun.Component.remove_listener">remove_listener</a></code></li>
<li><code><a title="tanjun.Component.started" href="#tanjun.Component.started">started</a></code></li>
<li><code><a title="tanjun.Component.with_check" href="#tanjun.Component.with_check">with_check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Context" href="#tanjun.Context">Context</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.Context.cache_service" href="#tanjun.Context.cache_service">cache_service</a></code></li>
<li><code><a title="tanjun.Context.command" href="#tanjun.Context.command">command</a></code></li>
<li><code><a title="tanjun.Context.content" href="#tanjun.Context.content">content</a></code></li>
<li><code><a title="tanjun.Context.dispatch_service" href="#tanjun.Context.dispatch_service">dispatch_service</a></code></li>
<li><code><a title="tanjun.Context.message" href="#tanjun.Context.message">message</a></code></li>
<li><code><a title="tanjun.Context.rest_service" href="#tanjun.Context.rest_service">rest_service</a></code></li>
<li><code><a title="tanjun.Context.shard" href="#tanjun.Context.shard">shard</a></code></li>
<li><code><a title="tanjun.Context.shard_service" href="#tanjun.Context.shard_service">shard_service</a></code></li>
<li><code><a title="tanjun.Context.triggering_name" href="#tanjun.Context.triggering_name">triggering_name</a></code></li>
<li><code><a title="tanjun.Context.triggering_prefix" href="#tanjun.Context.triggering_prefix">triggering_prefix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.ConversionError" href="#tanjun.ConversionError">ConversionError</a></code></h4>
<ul class="">
<li><code><a title="tanjun.ConversionError.errors" href="#tanjun.ConversionError.errors">errors</a></code></li>
<li><code><a title="tanjun.ConversionError.parameter" href="#tanjun.ConversionError.parameter">parameter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.EmojiConverter" href="#tanjun.EmojiConverter">EmojiConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.EmojiConverter.cache_bound" href="#tanjun.EmojiConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.EmojiConverter.convert" href="#tanjun.EmojiConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.EmojiConverter.intents" href="#tanjun.EmojiConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.EmojiConverter.is_inheritable" href="#tanjun.EmojiConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.EmojiConverter.types" href="#tanjun.EmojiConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.FailedCheck" href="#tanjun.FailedCheck">FailedCheck</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.GuildConverter" href="#tanjun.GuildConverter">GuildConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.GuildConverter.cache_bound" href="#tanjun.GuildConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.GuildConverter.convert" href="#tanjun.GuildConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.GuildConverter.intents" href="#tanjun.GuildConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.GuildConverter.is_inheritable" href="#tanjun.GuildConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.GuildConverter.types" href="#tanjun.GuildConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Hooks" href="#tanjun.Hooks">Hooks</a></code></h4>
<ul class="">
<li><code><a title="tanjun.Hooks.trigger_error" href="#tanjun.Hooks.trigger_error">trigger_error</a></code></li>
<li><code><a title="tanjun.Hooks.trigger_parser_error" href="#tanjun.Hooks.trigger_parser_error">trigger_parser_error</a></code></li>
<li><code><a title="tanjun.Hooks.trigger_post_execution" href="#tanjun.Hooks.trigger_post_execution">trigger_post_execution</a></code></li>
<li><code><a title="tanjun.Hooks.trigger_pre_execution" href="#tanjun.Hooks.trigger_pre_execution">trigger_pre_execution</a></code></li>
<li><code><a title="tanjun.Hooks.trigger_success" href="#tanjun.Hooks.trigger_success">trigger_success</a></code></li>
<li><code><a title="tanjun.Hooks.with_on_error" href="#tanjun.Hooks.with_on_error">with_on_error</a></code></li>
<li><code><a title="tanjun.Hooks.with_on_parser_error" href="#tanjun.Hooks.with_on_parser_error">with_on_parser_error</a></code></li>
<li><code><a title="tanjun.Hooks.with_on_success" href="#tanjun.Hooks.with_on_success">with_on_success</a></code></li>
<li><code><a title="tanjun.Hooks.with_post_execution" href="#tanjun.Hooks.with_post_execution">with_post_execution</a></code></li>
<li><code><a title="tanjun.Hooks.with_pre_execution" href="#tanjun.Hooks.with_pre_execution">with_pre_execution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.InviteConverter" href="#tanjun.InviteConverter">InviteConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.InviteConverter.cache_bound" href="#tanjun.InviteConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.InviteConverter.convert" href="#tanjun.InviteConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.InviteConverter.intents" href="#tanjun.InviteConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.InviteConverter.is_inheritable" href="#tanjun.InviteConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.InviteConverter.types" href="#tanjun.InviteConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.MemberConverter" href="#tanjun.MemberConverter">MemberConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.MemberConverter.cache_bound" href="#tanjun.MemberConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.MemberConverter.convert" href="#tanjun.MemberConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.MemberConverter.intents" href="#tanjun.MemberConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.MemberConverter.is_inheritable" href="#tanjun.MemberConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.MemberConverter.types" href="#tanjun.MemberConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.NotEnoughArgumentsError" href="#tanjun.NotEnoughArgumentsError">NotEnoughArgumentsError</a></code></h4>
<ul class="">
<li><code><a title="tanjun.NotEnoughArgumentsError.parameter" href="#tanjun.NotEnoughArgumentsError.parameter">parameter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.Option" href="#tanjun.Option">Option</a></code></h4>
<ul class="">
<li><code><a title="tanjun.Option.empty_value" href="#tanjun.Option.empty_value">empty_value</a></code></li>
<li><code><a title="tanjun.Option.names" href="#tanjun.Option.names">names</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.ParserError" href="#tanjun.ParserError">ParserError</a></code></h4>
<ul class="">
<li><code><a title="tanjun.ParserError.message" href="#tanjun.ParserError.message">message</a></code></li>
<li><code><a title="tanjun.ParserError.parameter" href="#tanjun.ParserError.parameter">parameter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.PresenceConverter" href="#tanjun.PresenceConverter">PresenceConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.PresenceConverter.cache_bound" href="#tanjun.PresenceConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.PresenceConverter.convert" href="#tanjun.PresenceConverter.convert">convert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.RoleConverter" href="#tanjun.RoleConverter">RoleConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.RoleConverter.cache_bound" href="#tanjun.RoleConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.RoleConverter.convert" href="#tanjun.RoleConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.RoleConverter.intents" href="#tanjun.RoleConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.RoleConverter.is_inheritable" href="#tanjun.RoleConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.RoleConverter.types" href="#tanjun.RoleConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.ShlexParser" href="#tanjun.ShlexParser">ShlexParser</a></code></h4>
<ul class="two-column">
<li><code><a title="tanjun.ShlexParser.add_parameter" href="#tanjun.ShlexParser.add_parameter">add_parameter</a></code></li>
<li><code><a title="tanjun.ShlexParser.bind_client" href="#tanjun.ShlexParser.bind_client">bind_client</a></code></li>
<li><code><a title="tanjun.ShlexParser.bind_component" href="#tanjun.ShlexParser.bind_component">bind_component</a></code></li>
<li><code><a title="tanjun.ShlexParser.parameters" href="#tanjun.ShlexParser.parameters">parameters</a></code></li>
<li><code><a title="tanjun.ShlexParser.parse" href="#tanjun.ShlexParser.parse">parse</a></code></li>
<li><code><a title="tanjun.ShlexParser.remove_parameter" href="#tanjun.ShlexParser.remove_parameter">remove_parameter</a></code></li>
<li><code><a title="tanjun.ShlexParser.set_parameters" href="#tanjun.ShlexParser.set_parameters">set_parameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.SnowflakeConverter" href="#tanjun.SnowflakeConverter">SnowflakeConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.SnowflakeConverter.cache_bound" href="#tanjun.SnowflakeConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.SnowflakeConverter.convert" href="#tanjun.SnowflakeConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.SnowflakeConverter.intents" href="#tanjun.SnowflakeConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.SnowflakeConverter.is_inheritable" href="#tanjun.SnowflakeConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.SnowflakeConverter.types" href="#tanjun.SnowflakeConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.StateWarning" href="#tanjun.StateWarning">StateWarning</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.TanjunError" href="#tanjun.TanjunError">TanjunError</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.TanjunWarning" href="#tanjun.TanjunWarning">TanjunWarning</a></code></h4>
</li>
<li>
<h4><code><a title="tanjun.TooManyArgumentsError" href="#tanjun.TooManyArgumentsError">TooManyArgumentsError</a></code></h4>
<ul class="">
<li><code><a title="tanjun.TooManyArgumentsError.parameter" href="#tanjun.TooManyArgumentsError.parameter">parameter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.UserConverter" href="#tanjun.UserConverter">UserConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.UserConverter.cache_bound" href="#tanjun.UserConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.UserConverter.convert" href="#tanjun.UserConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.UserConverter.intents" href="#tanjun.UserConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.UserConverter.is_inheritable" href="#tanjun.UserConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.UserConverter.types" href="#tanjun.UserConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.VoiceStateConverter" href="#tanjun.VoiceStateConverter">VoiceStateConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.VoiceStateConverter.cache_bound" href="#tanjun.VoiceStateConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.VoiceStateConverter.convert" href="#tanjun.VoiceStateConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.VoiceStateConverter.intents" href="#tanjun.VoiceStateConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.VoiceStateConverter.is_inheritable" href="#tanjun.VoiceStateConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.VoiceStateConverter.types" href="#tanjun.VoiceStateConverter.types">types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>