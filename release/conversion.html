<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tanjun.conversion API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tanjun.conversion</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

__all__: typing.Sequence[str] = [
    &#34;ChannelConverter&#34;,
    &#34;ColorConverter&#34;,
    &#34;EmojiConverter&#34;,
    &#34;GuildConverter&#34;,
    &#34;InviteConverter&#34;,
    &#34;MemberConverter&#34;,
    &#34;PresenceConverter&#34;,
    &#34;RoleConverter&#34;,
    &#34;SnowflakeConverter&#34;,
    &#34;UserConverter&#34;,
    &#34;VoiceStateConverter&#34;,
]

import abc
import distutils.util
import inspect
import re
import typing
import warnings

from hikari import channels
from hikari import colors
from hikari import emojis
from hikari import guilds
from hikari import intents as intents_
from hikari import invites
from hikari import presences
from hikari import snowflakes
from hikari import users
from hikari import voices

from tanjun import errors
from tanjun import traits

_ValueT = typing.TypeVar(&#34;_ValueT&#34;, covariant=True)


class BaseConverter(abc.ABC, typing.Generic[_ValueT], traits.StatelessConverter[_ValueT]):
    __slots__: typing.Sequence[str] = ()
    __implementations: typing.MutableSet[typing.Type[BaseConverter[typing.Type[typing.Any]]]] = set()

    @classmethod
    def bind_client(cls, client: traits.Client, /) -&gt; None:
        cache_bound = cls.cache_bound()
        if cache_bound and not client.cache_service:
            warnings.warn(
                f&#34;Registered converter {cls!r} will always fail with a stateless client.&#34;, category=errors.StateWarning
            )
            return

        if cache_bound:
            required_intents = cls.intents()
            if (required_intents &amp; client.shard_service.intents) != required_intents:
                warnings.warn(
                    f&#34;Registered converter {cls.__name__!r} will not run as expected &#34;
                    f&#34;when {required_intents!r} intent(s) are not declared&#34;,
                    category=errors.StateWarning,
                )

    @classmethod
    def bind_component(self, _: traits.Component, /) -&gt; None:
        pass

    @classmethod
    def get_from_type(
        cls, type_: typing.Type[_ValueT]
    ) -&gt; typing.Optional[typing.Type[BaseConverter[typing.Type[_ValueT]]]]:
        for converter in cls.__implementations:
            is_inheritable = converter.is_inheritable()
            if is_inheritable and issubclass(type_, converter.types()):
                return converter

            if not is_inheritable and type_ in converter.types():
                return converter

        return None

    @classmethod
    def implementations(cls) -&gt; typing.MutableSet[typing.Type[BaseConverter[typing.Type[typing.Any]]]]:
        return cls.__implementations

    @classmethod
    @abc.abstractmethod
    def cache_bound(cls) -&gt; bool:
        raise NotImplementedError

    @classmethod
    @abc.abstractmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; _ValueT:
        raise NotImplementedError

    @classmethod
    @abc.abstractmethod
    def intents(cls) -&gt; intents_.Intents:
        raise NotImplementedError

    @classmethod
    @abc.abstractmethod
    def is_inheritable(cls) -&gt; bool:
        raise NotImplementedError

    @classmethod
    @abc.abstractmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        raise NotImplementedError


class ChannelConverter(BaseConverter[channels.GuildChannel]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; channels.GuildChannel:
        if ctx.client.cache_service:
            channel_id = ChannelIDParser.match_id(argument, message=&#34;No valid channel mention or ID  found&#34;)
            if channel := ctx.client.cache_service.cache.get_guild_channel(channel_id):
                return channel

        raise ValueError(&#34;Couldn&#39;t find channel&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (channels.GuildChannel,)


class ColorConverter(BaseConverter[colors.Color]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; typing.Any:
        values = argument.split(&#34; &#34;)
        if all(value.isdigit() for value in values):
            return colors.Color.of(*map(int, values))

        return colors.Color.of(*values)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (colors.Color,)


class EmojiConverter(BaseConverter[emojis.KnownCustomEmoji]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; emojis.KnownCustomEmoji:
        if ctx.client.cache_service:
            emoji_id = EmojiIDParser.match_id(argument, message=&#34;No valid emoji or emoji ID found&#34;)
            if emoji := ctx.client.cache_service.cache.get_emoji(emoji_id):
                return emoji

        raise ValueError(&#34;Couldn&#39;t find emoji&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_EMOJIS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (emojis.CustomEmoji,)


class GuildConverter(BaseConverter[guilds.GatewayGuild]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.GatewayGuild:
        if ctx.client.cache_service:
            guild_id = SnowflakeParser.match_id(argument, message=&#34;No valid guild ID found&#34;)
            if guild := ctx.client.cache_service.cache.get_guild(guild_id):
                return guild

        raise ValueError(&#34;Couldn&#39;t find guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Guild,)


class InviteConverter(BaseConverter[invites.InviteWithMetadata]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; invites.InviteWithMetadata:
        if ctx.client.cache_service:
            if invite := ctx.client.cache_service.cache.get_invite(argument):
                return invite

        raise ValueError(&#34;Couldn&#39;t find invite&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_INVITES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (invites.Invite,)


class MemberConverter(BaseConverter[guilds.Member]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Member:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a member from a DM channel&#34;)

        if ctx.client.cache_service:
            member_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID found&#34;)
            if member := ctx.client.cache_service.cache.get_member(ctx.message.guild_id, member_id):
                return member

        raise ValueError(&#34;Couldn&#39;t find member in this guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Member,)


class PresenceConverter(BaseConverter[presences.MemberPresence]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; presences.MemberPresence:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a presence from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid member mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_presence(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find presence in current guild&#34;)


class RoleConverter(BaseConverter[guilds.Role]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Role:
        if ctx.client.cache_service:
            role_id = SnowflakeParser.match_id(argument, message=&#34;No valid role mention or ID  found&#34;)
            if role := ctx.client.cache_service.cache.get_role(role_id):
                return role

        raise ValueError(&#34;Couldn&#39;t find role&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Role,)


class BaseSnowflakeParser:
    __slots__: typing.Sequence[str] = ()

    @classmethod
    @abc.abstractmethod
    def regex(cls) -&gt; typing.Pattern[str]:
        raise NotImplementedError

    @classmethod
    def match_id(cls, value: str, *, message: str = &#34;No valid mention or ID found&#34;) -&gt; snowflakes.Snowflake:
        result: typing.Optional[snowflakes.Snowflake] = None
        value = value.strip()
        if value.isdigit():
            result = snowflakes.Snowflake(value)

        else:
            try:
                result = snowflakes.Snowflake(next(cls.regex().finditer(value)).groups()[0])

            except StopIteration:
                pass

        # We should also range check the provided ID.
        if result is not None and snowflakes.Snowflake.min() &lt;= result &lt;= snowflakes.Snowflake.max():
            return result

        raise ValueError(message) from None


class SnowflakeParser(BaseSnowflakeParser):
    __slots__: typing.Sequence[str] = ()
    _pattern = re.compile(r&#34;&lt;[@&amp;?!#a]{0,3}(?::\w+:)?(\d+)&gt;&#34;)

    @classmethod
    def regex(cls) -&gt; typing.Pattern[str]:
        return cls._pattern


class ChannelIDParser(BaseSnowflakeParser):
    __slots__: typing.Sequence[str] = ()
    _pattern = re.compile(r&#34;&lt;#(\d+)&gt;&#34;)

    @classmethod
    def regex(cls) -&gt; typing.Pattern[str]:
        return cls._pattern


class EmojiIDParser(BaseSnowflakeParser):
    __slots__: typing.Sequence[str] = ()
    _pattern = re.compile(r&#34;&lt;a?:\w+:(\d+)&gt;&#34;)

    @classmethod
    def regex(cls) -&gt; typing.Pattern[str]:
        return cls._pattern


class UserIDParser(BaseSnowflakeParser):
    __slots__: typing.Sequence[str] = ()
    _pattern = re.compile(r&#34;&lt;@!?(\d+)&gt;&#34;)

    @classmethod
    def regex(cls) -&gt; typing.Pattern[str]:
        return cls._pattern


class SnowflakeConverter(BaseConverter[snowflakes.Snowflake]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; snowflakes.Snowflake:
        return SnowflakeParser.match_id(argument, message=&#34;No valid ID found&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (snowflakes.Snowflake,)


class UserConverter(BaseConverter[users.User]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; users.User:
        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_user(user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find user&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (users.User,)


class VoiceStateConverter(BaseConverter[voices.VoiceState]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; voices.VoiceState:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a voice state from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_voice_state(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Voice state couldn&#39;t be found for current guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_VOICE_STATES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (voices.VoiceState,)


for _cls in vars().copy().values():
    if inspect.isclass(_cls) and issubclass(_cls, BaseConverter):
        BaseConverter.implementations().add(_cls)

del _cls


_BUILTIN_TYPE_OVERRIDES: typing.Mapping[typing.Callable[..., typing.Any], typing.Callable[[str], typing.Any]] = {
    bool: distutils.util.strtobool,
    bytes: lambda d: bytes(d, &#34;utf-8&#34;),
    bytearray: lambda d: bytearray(d, &#34;utf-8&#34;),
}


def override_builtin_type(cls: traits.ConverterT) -&gt; traits.ConverterT:
    if callable(cls):
        return _BUILTIN_TYPE_OVERRIDES.get(cls, cls)

    return cls</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tanjun.conversion.ChannelConverter"><code class="flex name class">
<span>class <span class="ident">ChannelConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelConverter(BaseConverter[channels.GuildChannel]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; channels.GuildChannel:
        if ctx.client.cache_service:
            channel_id = ChannelIDParser.match_id(argument, message=&#34;No valid channel mention or ID  found&#34;)
            if channel := ctx.client.cache_service.cache.get_guild_channel(channel_id):
                return channel

        raise ValueError(&#34;Couldn&#39;t find channel&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (channels.GuildChannel,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.ChannelConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ChannelConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.channels.GuildChannel</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; channels.GuildChannel:
    if ctx.client.cache_service:
        channel_id = ChannelIDParser.match_id(argument, message=&#34;No valid channel mention or ID  found&#34;)
        if channel := ctx.client.cache_service.cache.get_guild_channel(channel_id):
            return channel

    raise ValueError(&#34;Couldn&#39;t find channel&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ChannelConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ChannelConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ChannelConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (channels.GuildChannel,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.ColorConverter"><code class="flex name class">
<span>class <span class="ident">ColorConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColorConverter(BaseConverter[colors.Color]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; typing.Any:
        values = argument.split(&#34; &#34;)
        if all(value.isdigit() for value in values):
            return colors.Color.of(*map(int, values))

        return colors.Color.of(*values)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (colors.Color,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.ColorConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ColorConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>_: traits.Context, argument: str, /) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, _: traits.Context, argument: str, /) -&gt; typing.Any:
    values = argument.split(&#34; &#34;)
    if all(value.isdigit() for value in values):
        return colors.Color.of(*map(int, values))

    return colors.Color.of(*values)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ColorConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.NONE</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ColorConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.ColorConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (colors.Color,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.EmojiConverter"><code class="flex name class">
<span>class <span class="ident">EmojiConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmojiConverter(BaseConverter[emojis.KnownCustomEmoji]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; emojis.KnownCustomEmoji:
        if ctx.client.cache_service:
            emoji_id = EmojiIDParser.match_id(argument, message=&#34;No valid emoji or emoji ID found&#34;)
            if emoji := ctx.client.cache_service.cache.get_emoji(emoji_id):
                return emoji

        raise ValueError(&#34;Couldn&#39;t find emoji&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_EMOJIS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (emojis.CustomEmoji,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.EmojiConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.EmojiConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.emojis.KnownCustomEmoji</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; emojis.KnownCustomEmoji:
    if ctx.client.cache_service:
        emoji_id = EmojiIDParser.match_id(argument, message=&#34;No valid emoji or emoji ID found&#34;)
        if emoji := ctx.client.cache_service.cache.get_emoji(emoji_id):
            return emoji

    raise ValueError(&#34;Couldn&#39;t find emoji&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.EmojiConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_EMOJIS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.EmojiConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.EmojiConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (emojis.CustomEmoji,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.GuildConverter"><code class="flex name class">
<span>class <span class="ident">GuildConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuildConverter(BaseConverter[guilds.GatewayGuild]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.GatewayGuild:
        if ctx.client.cache_service:
            guild_id = SnowflakeParser.match_id(argument, message=&#34;No valid guild ID found&#34;)
            if guild := ctx.client.cache_service.cache.get_guild(guild_id):
                return guild

        raise ValueError(&#34;Couldn&#39;t find guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Guild,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.GuildConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.GuildConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.guilds.GatewayGuild</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.GatewayGuild:
    if ctx.client.cache_service:
        guild_id = SnowflakeParser.match_id(argument, message=&#34;No valid guild ID found&#34;)
        if guild := ctx.client.cache_service.cache.get_guild(guild_id):
            return guild

    raise ValueError(&#34;Couldn&#39;t find guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.GuildConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.GuildConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.GuildConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Guild,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.InviteConverter"><code class="flex name class">
<span>class <span class="ident">InviteConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InviteConverter(BaseConverter[invites.InviteWithMetadata]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; invites.InviteWithMetadata:
        if ctx.client.cache_service:
            if invite := ctx.client.cache_service.cache.get_invite(argument):
                return invite

        raise ValueError(&#34;Couldn&#39;t find invite&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_INVITES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return True

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (invites.Invite,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.InviteConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.InviteConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.invites.InviteWithMetadata</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; invites.InviteWithMetadata:
    if ctx.client.cache_service:
        if invite := ctx.client.cache_service.cache.get_invite(argument):
            return invite

    raise ValueError(&#34;Couldn&#39;t find invite&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.InviteConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_INVITES</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.InviteConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.InviteConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (invites.Invite,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.MemberConverter"><code class="flex name class">
<span>class <span class="ident">MemberConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemberConverter(BaseConverter[guilds.Member]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Member:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a member from a DM channel&#34;)

        if ctx.client.cache_service:
            member_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID found&#34;)
            if member := ctx.client.cache_service.cache.get_member(ctx.message.guild_id, member_id):
                return member

        raise ValueError(&#34;Couldn&#39;t find member in this guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Member,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.MemberConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.MemberConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.guilds.Member</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Member:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a member from a DM channel&#34;)

    if ctx.client.cache_service:
        member_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID found&#34;)
        if member := ctx.client.cache_service.cache.get_member(ctx.message.guild_id, member_id):
            return member

    raise ValueError(&#34;Couldn&#39;t find member in this guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.MemberConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_MEMBERS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.MemberConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.MemberConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Member,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.PresenceConverter"><code class="flex name class">
<span>class <span class="ident">PresenceConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresenceConverter(BaseConverter[presences.MemberPresence]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; presences.MemberPresence:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a presence from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid member mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_presence(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find presence in current guild&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.PresenceConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.PresenceConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.presences.MemberPresence</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; presences.MemberPresence:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a presence from a DM channel&#34;)

    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid member mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_presence(ctx.message.guild_id, user_id):
            return user

    raise ValueError(&#34;Couldn&#39;t find presence in current guild&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.RoleConverter"><code class="flex name class">
<span>class <span class="ident">RoleConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoleConverter(BaseConverter[guilds.Role]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Role:
        if ctx.client.cache_service:
            role_id = SnowflakeParser.match_id(argument, message=&#34;No valid role mention or ID  found&#34;)
            if role := ctx.client.cache_service.cache.get_role(role_id):
                return role

        raise ValueError(&#34;Couldn&#39;t find role&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILDS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (guilds.Role,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.RoleConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.RoleConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.guilds.Role</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; guilds.Role:
    if ctx.client.cache_service:
        role_id = SnowflakeParser.match_id(argument, message=&#34;No valid role mention or ID  found&#34;)
        if role := ctx.client.cache_service.cache.get_role(role_id):
            return role

    raise ValueError(&#34;Couldn&#39;t find role&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.RoleConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILDS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.RoleConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.RoleConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (guilds.Role,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.SnowflakeConverter"><code class="flex name class">
<span>class <span class="ident">SnowflakeConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnowflakeConverter(BaseConverter[snowflakes.Snowflake]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return False

    @classmethod
    async def convert(cls, _: traits.Context, argument: str, /) -&gt; snowflakes.Snowflake:
        return SnowflakeParser.match_id(argument, message=&#34;No valid ID found&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.NONE

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (snowflakes.Snowflake,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.SnowflakeConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.SnowflakeConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>_: traits.Context, argument: str, /) ‑> hikari.snowflakes.Snowflake</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, _: traits.Context, argument: str, /) -&gt; snowflakes.Snowflake:
    return SnowflakeParser.match_id(argument, message=&#34;No valid ID found&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.SnowflakeConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.NONE</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.SnowflakeConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.SnowflakeConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (snowflakes.Snowflake,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.UserConverter"><code class="flex name class">
<span>class <span class="ident">UserConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserConverter(BaseConverter[users.User]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; users.User:
        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_user(user_id):
                return user

        raise ValueError(&#34;Couldn&#39;t find user&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_MEMBERS

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (users.User,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.UserConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.UserConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.users.User</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; users.User:
    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_user(user_id):
            return user

    raise ValueError(&#34;Couldn&#39;t find user&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.UserConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_MEMBERS</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.UserConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.UserConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (users.User,)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tanjun.conversion.VoiceStateConverter"><code class="flex name class">
<span>class <span class="ident">VoiceStateConverter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoiceStateConverter(BaseConverter[voices.VoiceState]):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def cache_bound(cls) -&gt; bool:
        return True

    @classmethod
    async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; voices.VoiceState:
        if ctx.message.guild_id is None:
            raise ValueError(&#34;Cannot get a voice state from a DM channel&#34;)

        if ctx.client.cache_service:
            user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
            if user := ctx.client.cache_service.cache.get_voice_state(ctx.message.guild_id, user_id):
                return user

        raise ValueError(&#34;Voice state couldn&#39;t be found for current guild&#34;)

    @classmethod
    def intents(cls) -&gt; intents_.Intents:
        return intents_.Intents.GUILD_VOICE_STATES

    @classmethod
    def is_inheritable(cls) -&gt; bool:
        return False

    @classmethod
    def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
        return (voices.VoiceState,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tanjun.conversion.BaseConverter</li>
<li>abc.ABC</li>
<li><a title="tanjun.traits.StatelessConverter" href="traits.html#tanjun.traits.StatelessConverter">StatelessConverter</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tanjun.conversion.VoiceStateConverter.cache_bound"><code class="name flex">
<span>def <span class="ident">cache_bound</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cache_bound(cls) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.VoiceStateConverter.convert"><code class="name flex">
<span>async def <span class="ident">convert</span></span>(<span>ctx: traits.Context, argument: str, /) ‑> hikari.voices.VoiceState</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def convert(cls, ctx: traits.Context, argument: str, /) -&gt; voices.VoiceState:
    if ctx.message.guild_id is None:
        raise ValueError(&#34;Cannot get a voice state from a DM channel&#34;)

    if ctx.client.cache_service:
        user_id = UserIDParser.match_id(argument, message=&#34;No valid user mention or ID  found&#34;)
        if user := ctx.client.cache_service.cache.get_voice_state(ctx.message.guild_id, user_id):
            return user

    raise ValueError(&#34;Voice state couldn&#39;t be found for current guild&#34;)</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.VoiceStateConverter.intents"><code class="name flex">
<span>def <span class="ident">intents</span></span>(<span>) ‑> hikari.intents.Intents</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def intents(cls) -&gt; intents_.Intents:
    return intents_.Intents.GUILD_VOICE_STATES</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.VoiceStateConverter.is_inheritable"><code class="name flex">
<span>def <span class="ident">is_inheritable</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_inheritable(cls) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="tanjun.conversion.VoiceStateConverter.types"><code class="name flex">
<span>def <span class="ident">types</span></span>(<span>) ‑> Tuple[Type[Any], ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def types(cls) -&gt; typing.Tuple[typing.Type[typing.Any], ...]:
    return (voices.VoiceState,)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tanjun" href="index.html">tanjun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tanjun.conversion.ChannelConverter" href="#tanjun.conversion.ChannelConverter">ChannelConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.ChannelConverter.cache_bound" href="#tanjun.conversion.ChannelConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.ChannelConverter.convert" href="#tanjun.conversion.ChannelConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.ChannelConverter.intents" href="#tanjun.conversion.ChannelConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.ChannelConverter.is_inheritable" href="#tanjun.conversion.ChannelConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.ChannelConverter.types" href="#tanjun.conversion.ChannelConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.ColorConverter" href="#tanjun.conversion.ColorConverter">ColorConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.ColorConverter.cache_bound" href="#tanjun.conversion.ColorConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.ColorConverter.convert" href="#tanjun.conversion.ColorConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.ColorConverter.intents" href="#tanjun.conversion.ColorConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.ColorConverter.is_inheritable" href="#tanjun.conversion.ColorConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.ColorConverter.types" href="#tanjun.conversion.ColorConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.EmojiConverter" href="#tanjun.conversion.EmojiConverter">EmojiConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.EmojiConverter.cache_bound" href="#tanjun.conversion.EmojiConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.EmojiConverter.convert" href="#tanjun.conversion.EmojiConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.EmojiConverter.intents" href="#tanjun.conversion.EmojiConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.EmojiConverter.is_inheritable" href="#tanjun.conversion.EmojiConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.EmojiConverter.types" href="#tanjun.conversion.EmojiConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.GuildConverter" href="#tanjun.conversion.GuildConverter">GuildConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.GuildConverter.cache_bound" href="#tanjun.conversion.GuildConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.GuildConverter.convert" href="#tanjun.conversion.GuildConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.GuildConverter.intents" href="#tanjun.conversion.GuildConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.GuildConverter.is_inheritable" href="#tanjun.conversion.GuildConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.GuildConverter.types" href="#tanjun.conversion.GuildConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.InviteConverter" href="#tanjun.conversion.InviteConverter">InviteConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.InviteConverter.cache_bound" href="#tanjun.conversion.InviteConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.InviteConverter.convert" href="#tanjun.conversion.InviteConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.InviteConverter.intents" href="#tanjun.conversion.InviteConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.InviteConverter.is_inheritable" href="#tanjun.conversion.InviteConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.InviteConverter.types" href="#tanjun.conversion.InviteConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.MemberConverter" href="#tanjun.conversion.MemberConverter">MemberConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.MemberConverter.cache_bound" href="#tanjun.conversion.MemberConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.MemberConverter.convert" href="#tanjun.conversion.MemberConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.MemberConverter.intents" href="#tanjun.conversion.MemberConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.MemberConverter.is_inheritable" href="#tanjun.conversion.MemberConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.MemberConverter.types" href="#tanjun.conversion.MemberConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.PresenceConverter" href="#tanjun.conversion.PresenceConverter">PresenceConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.PresenceConverter.cache_bound" href="#tanjun.conversion.PresenceConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.PresenceConverter.convert" href="#tanjun.conversion.PresenceConverter.convert">convert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.RoleConverter" href="#tanjun.conversion.RoleConverter">RoleConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.RoleConverter.cache_bound" href="#tanjun.conversion.RoleConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.RoleConverter.convert" href="#tanjun.conversion.RoleConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.RoleConverter.intents" href="#tanjun.conversion.RoleConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.RoleConverter.is_inheritable" href="#tanjun.conversion.RoleConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.RoleConverter.types" href="#tanjun.conversion.RoleConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.SnowflakeConverter" href="#tanjun.conversion.SnowflakeConverter">SnowflakeConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.SnowflakeConverter.cache_bound" href="#tanjun.conversion.SnowflakeConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.SnowflakeConverter.convert" href="#tanjun.conversion.SnowflakeConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.SnowflakeConverter.intents" href="#tanjun.conversion.SnowflakeConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.SnowflakeConverter.is_inheritable" href="#tanjun.conversion.SnowflakeConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.SnowflakeConverter.types" href="#tanjun.conversion.SnowflakeConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.UserConverter" href="#tanjun.conversion.UserConverter">UserConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.UserConverter.cache_bound" href="#tanjun.conversion.UserConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.UserConverter.convert" href="#tanjun.conversion.UserConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.UserConverter.intents" href="#tanjun.conversion.UserConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.UserConverter.is_inheritable" href="#tanjun.conversion.UserConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.UserConverter.types" href="#tanjun.conversion.UserConverter.types">types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tanjun.conversion.VoiceStateConverter" href="#tanjun.conversion.VoiceStateConverter">VoiceStateConverter</a></code></h4>
<ul class="">
<li><code><a title="tanjun.conversion.VoiceStateConverter.cache_bound" href="#tanjun.conversion.VoiceStateConverter.cache_bound">cache_bound</a></code></li>
<li><code><a title="tanjun.conversion.VoiceStateConverter.convert" href="#tanjun.conversion.VoiceStateConverter.convert">convert</a></code></li>
<li><code><a title="tanjun.conversion.VoiceStateConverter.intents" href="#tanjun.conversion.VoiceStateConverter.intents">intents</a></code></li>
<li><code><a title="tanjun.conversion.VoiceStateConverter.is_inheritable" href="#tanjun.conversion.VoiceStateConverter.is_inheritable">is_inheritable</a></code></li>
<li><code><a title="tanjun.conversion.VoiceStateConverter.types" href="#tanjun.conversion.VoiceStateConverter.types">types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>